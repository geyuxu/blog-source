[{"title":"contab 简单使用笔记","url":"/2017/06/27/linux/2017-06-27-contab简单使用笔记/","content":"\n基本格式：\n日：1-31\n\n月：1-12\n\n周：0-6\n\n每n分钟：*/n \n\n并列：3,5,8\n\n<!--more-->\n例：\n\n\n\n\n\n","tags":["contab"]},{"title":"varnish 安装","url":"/2016/11/11/linux/varnish 安装/","content":"\n1. 安装\n\n\trpm -ivh http://download.fedoraproject.org/pub/epel/6/x86_64/epel-release-6-8.noarch.rpm\n\trpm --nosignature -i https://repo.varnish-cache.org/redhat/varnish-4.1.el6.rpm\n\tyum install varnish\n\n\t**EPEL 是yum的一个软件源,里面包含了许多基本源里没有的软件。**\n  **官方的安装文档：http://varnish-cache.org/releases/index.html**\n<!--more-->\n2. 配置文件\n\n\t1) varnish 配置文件： /etc/sysconfig/varnish\n\t\n\t```\n\n\t\t* VARNISH_STORAGE_SIZE 为缓存文件大小\n\t\t\n\t\tVARNISH_STORAGE_SIZE=100T\n\t\t\n\t\t* VARNISH_STORAGE 为缓存方式，配置为 file 形式\n\t\t\n\t\tVARNISH_STORAGE_FILE=/root/varnish.cache\n\t\t\n\t\tVARNISH_STORAGE=\"file,${VARNISH_STORAGE_FILE},${VARNISH_STORAGE_SIZE}\"\n\t```\n\n\t2) vcl 配置文件： /etc/varnish/*.vcl\n\n3. 启动 varnish\n\tservice varnish start\n\tservice varnishlog start\n\n4. 加载 vcl\n\n1） 进入 varnishadm \n\n\tvarnishadm -S /etc/varnish/secret -T 127.0.0.1:6082\n\n2） 查看现有配置\n\n\tvarnish> vcl.list\n\n\tavailable  auto/cold          0 boot\n\tavailable  auto/cold          0 ceph1\n\tavailable  auto/warm          0 ceph2\n\tavailable  auto/warm          0 ceph3\n\tavailable  auto/cold          0 ceph4\n\tavailable  auto/cold          0 ceph5\n\tavailable  auto/cold          0 ceph6\n\tavailable  auto/cold          0 ceph7\n\tactive     auto/warm          0 ceph8\n\n\t* active 为现在活动的配置\n\t* boot/ceph1-8 为加载过的配置\n\n3） 加载一个 vcl 配置\n\n\tvarnish> vcl.load ceph9 ceph.vcl\n\t\n\t* ceph9 为自定义名称，与上面 list 中的名称不能重复\n\t* ceph.vcl 默认 path 为 /etc/varnish/\n\t* 此时 ceph9 的状态为 available\n\n\tavailable  auto/warm          0 ceph9\n\n4. 启用配置\n\n\tvarnish> vcl.use ceph9\n","tags":["varnish"]},{"title":"这是在docker容器中发布的博客","url":"/2016/04/26/others/这是在docker容器中发布的博客/","content":"\n 这是在 docker 容器中发布的一篇博客\n"},{"title":"spring-boot JSP配置","url":"/2016/04/09/java/spring-boot JSP配置/","content":"\n新建一个maven工程，pom.xml 文件如下:\n\n\t<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n    <project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n             xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n             xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n        <modelVersion>4.0.0</modelVersion>\n\n        <groupId>com.geyuxu</groupId>\n        <artifactId>jsp-sample</artifactId>\n        <version>1.0-SNAPSHOT</version>\n\n        <parent>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-parent</artifactId>\n            <version>1.3.3.RELEASE</version>\n        </parent>\n\n        <dependencies>\n            <!--spring boot-->\n            <dependency>\n                <groupId>org.springframework.boot</groupId>\n                <artifactId>spring-boot-devtools</artifactId>\n                <optional>true</optional>\n            </dependency>\n            <dependency>\n                <groupId>org.springframework.boot</groupId>\n                <artifactId>spring-boot-starter</artifactId>\n            </dependency>\n            <dependency>\n                <groupId>org.springframework.boot</groupId>\n                <artifactId>spring-boot-starter-tomcat</artifactId>\n            </dependency>\n            <dependency>\n                <groupId>org.springframework</groupId>\n                <artifactId>spring-webmvc</artifactId>\n            </dependency>\n\n            <!--tomcat-->\n            <dependency>\n                <groupId>org.apache.tomcat.embed</groupId>\n                <artifactId>tomcat-embed-jasper</artifactId>\n            </dependency>\n\n        </dependencies>\n\n        <build>\n            <plugins>\n                <plugin>\n                    <groupId>org.springframework.boot</groupId>\n                    <artifactId>spring-boot-maven-plugin</artifactId>\n                </plugin>\n            </plugins>\n        </build>\n    </project>\n<!--more-->\nmaven install 后，创建 Application 类，用于启动工程：\n\n\tpackage com.geyuxu;\n    \n    import org.springframework.boot.SpringApplication;\n    import org.springframework.boot.autoconfigure.SpringBootApplication;\n    \n    /**\n     * @author 葛于旭\n     * @version V3.0\n     * @ClassName: Application\n     * @date 2016年04月09日 20:03:03\n     */\n    @SpringBootApplication\n    public class Application {\n        public static void main(String[] args) {\n            SpringApplication.run(Application.class, args);\n        }\n    }\n   \n   \n创建 WebConfig 类，此类用于配置 web 工程 ，替代了原先的配置文件：\n\n\tpackage com.geyuxu.config;\n    \n    import org.springframework.context.annotation.Bean;\n    import org.springframework.context.annotation.ComponentScan;\n    import org.springframework.context.annotation.Configuration;\n    import org.springframework.web.servlet.DispatcherServlet;\n    import org.springframework.web.servlet.config.annotation.DefaultServletHandlerConfigurer;\n    import org.springframework.web.servlet.config.annotation.EnableWebMvc;\n    import org.springframework.web.servlet.config.annotation.WebMvcConfigurerAdapter;\n    import org.springframework.web.servlet.view.InternalResourceViewResolver;\n    \n    /**\n     * @author 葛于旭\n     * @version V3.0\n     * @ClassName: WebConfig\n     * @date 2016年04月09日 15:20:03\n     */\n    @EnableWebMvc\n    @ComponentScan\n    @Configuration\n    public class WebConfig extends WebMvcConfigurerAdapter {\n    \n        @Bean\n        public InternalResourceViewResolver defaultViewResolver() {\n            InternalResourceViewResolver viewResolver = new InternalResourceViewResolver();\n            viewResolver.setPrefix(\"/pages/\");\n            viewResolver.setSuffix(\".jsp\");\n            return viewResolver;\n        }\n    \n        @Bean\n        public DispatcherServlet dispatcherServlet() {\n            return new DispatcherServlet();\n        }\n    \n        @Override\n        public void configureDefaultServletHandling(\n                DefaultServletHandlerConfigurer configurer) {\n            configurer.enable();\n        }\n    }\n    \n在 src/main/webapp/WEB-INF 目录下创建 web.xml 文件：\n\n\t<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n    <web-app version=\"2.5\" xmlns=\"http://java.sun.com/xml/ns/javaee\"\n             xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n             xsi:schemaLocation=\"http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd\">\n    \n        <servlet>\n            <servlet-name>appServlet</servlet-name>\n            <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>\n            <init-param>\n                <param-name>contextClass</param-name>\n                <param-value>org.springframework.web.context.support.AnnotationConfigWebApplicationContext</param-value>\n            </init-param>\n            <init-param>\n                <param-name>contextConfigLocation</param-name>\n                <param-value>com.bailiangroup.blcp.message.config</param-value>\n            </init-param>\n            <load-on-startup>1</load-on-startup>\n        </servlet>\n    \n        <servlet-mapping>\n            <servlet-name>appServlet</servlet-name>\n            <url-pattern>/</url-pattern>\n        </servlet-mapping>\n    \n        <!-- Disables Servlet Container welcome file handling. Needed for compatibility\n            with Servlet 3.0 and Tomcat 7.0 -->\n        <welcome-file-list>\n            <welcome-file></welcome-file>\n        </welcome-file-list>\n    \n    </web-app>\n    \n下面写一个 Controller 验证是否成功\n\n\t@Controller\n\tpublic class MyController {\n\n\t\t@RequestMapping(value=\"/test\")\n\t\tpublic String test(){\n\t\t\treturn \"a\";\n\t\t}\n\t\t\n\t}\n    \n在 webapp/pages 目录下创建 a.jsp\n\n\t<%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %>\n\t<html>\n\t\t<head>\n \t  \t\t<title></title>\n\t\t</head>\n\t\t<body>\n \t \t\t<h1>hi~</h1>\n\t\t</body>\n\t</html>\n\n运行 Application.main() 方法，在浏览器大开默认地址 http://localhost:8080/test 。如果以上步骤正确，就能看到结果了。\n\n------\n[]()\n\n","tags":["jsp"]},{"title":"svn常用命令","url":"/2016/03/25/others/svn常用命令/","content":"checkout:\n\n\tsvn --username yourusername --password yourpassword co svn_path local_path \n\ndiff:\n\n\tsvn diff -r 3 text.c\n\nlist:\n\n\tsvn list -v http://svn.test.com/svn\n\t\ncat:\n\n\tsvn cat -r 4 test.c \n\t\nsvn add file|dir -- 添加文件或整个目录\n\nsvn commit  -- 提交本地修改代码\n\nsvn status    -- 查看本地修改代码情况：修改的或本地独有的文件详细信息\n\nsvn merge   -- 合并svn和本地代码\n\nsvn revert   -- 撤销本地修改代码\n\nsvn resolve -- 合并冲突代码\n\nsvn help [command] -- 查看svn帮助，或特定命令帮助\n------\n参考资料：\n\n[http://www.iteye.com/problems/58166](http://www.iteye.com/problems/58166)\n\n[http://www.cnblogs.com/zhenjing/archive/2012/12/22/svn_usage.html](http://www.cnblogs.com/zhenjing/archive/2012/12/22/svn_usage.html)\n\n","tags":["svn"]},{"title":"常用jdbc连接字符串(持续更新)","url":"/2016/03/25/java/常用jdbc连接字符串/","content":"\nmysql\n-----\n\ndriverClass:\n\n\tcom.mysql.jdbc.Driver\n\t\nurl：\n\n\tjdbc:mysql://localhost:3306/dbname?useUnicode=true&characterEncoding=utf-8\n\nmemsql\n-----\n<!--more-->\ndriverClass:\n\n\tcom.mysql.jdbc.Driver\n\t\nurl：\n\n\tjdbc:mysql://localhost:3306/dbname?useUnicode=true&amp;charset=UTF-8&zeroDateTimeBehavior=convertToNull&amp;transformedBitIsBoolean=true\n\t\noracle\n-----\n\ndriverClass:\n\n\toracle.jdbc.driver.OracleDriver\n\t\nurl：\n\n\tjdbc:oracle:thin:@localhost:3306/dbname\n\t\nDB2\n-----\n\ndriverClass:\n    \n    com.ibm.db2.jcc.DB2Driver\n    \nurl：\n\n    jdbc:db2://localhost:50000/dbname\n    \nsybase\n-----\n\ndriverClass：\n\n\tcom.sybase.jdbc.SybDriver\n    \nurl：\n\n\tjdbc:sybase:Tds:localhost:5007/dbname\n    \nPostgreSQL\n-----\n\ndriverClass：\n\t\n\torg.postgresql.Driver\n    \nurl：\n\t\n\tjdbc:postgresql://localhost/dbname\n    \nSql Server2000\n-----\n\ndriverClass：\n\t\n\tcom.microsoft.jdbc.sqlserver.SQLServerDriver\n    \nurl：\n\t\n\tjdbc:microsoft:sqlserver://localhost:1433;DatabaseName=dbname\n    \nSql Server2005\n-----\n\ndriverClass：\n\t\n\tcom.microsoft.sqlserver.jdbc.SQLServerDriver\n    \nurl：\n\n\tjdbc:sqlserver://localhost:1433; DatabaseName=dbname\n\t\naccess\n-----\n\ndriverClass：\n\t\n\tsun.jdbc.odbc.JdbcOdbcDriver\n\t\nurl：\n\n\tjdbc:odbc:driver={Microsoft Access Driver (*.mdb)};DBQ=C://your/path/dbname.mdb\n\t\n\t\nsqlite\n-----\n\ndriverClass:\n\n\torg.sqlite.JDBC\nurl：\t\n\n\tjdbc:sqlite:/your/path/database.db\n\n------\n参考资料：\n\n[http://www.cnblogs.com/gulvzhe/archive/2012/08/24/2653867.html](http://www.cnblogs.com/gulvzhe/archive/2012/08/24/2653867.html)\n\n[SQLite文本数据库JDBC连接使用介绍](http://just4java.iteye.com/blog/2108541)\n\n[详解JDBC连接Access的三种方法](http://developer.51cto.com/art/200907/138837.htm)","tags":["jdbc"]},{"title":"nodejs操作文件","url":"/2016/03/18/nodejs/nodejs操作文件/","content":"向文件中写数据：\n\n\tvar txt = '保存的数据';\n\tfs.writeFile('message.txt', \t\n\t\t txt, (err) => {\n\t\t\tif (err) throw err;\n\t\t\tconsole.log('It\\'s saved!');\n\t\t}\n\t);\n\t\nfs.writeFile的同步方法是\n\n\tfs.writeFileSync(file, data[, options])\n\n从文件中读取数据：\n\t\n\tfs.readFile('/etc/passwd', (err, data) => {\n\t\tif (err) throw err;\n\t\tconsole.log(data);\n\t});\n\n-----------------\n[node官方文档](https://nodejs.org/dist/latest-v5.x/docs/api/fs.html#fs_fs_writefile_file_data_options_callback) ","tags":["nodejs"]},{"title":"fortify 基本命令","url":"/2016/03/17/security/fortify 基本命令/","content":"\n转换单一个文件 myServlet.java 并指定classpath为 lib/j2ee.jar其命令为:\r\r\tsourceanalyzer -b MyServlet -cp lib/j2ee.jar MyServlet.java\n\r\t\r转换src目录下的所有.java文件并指定classpath为 lib目录下的所有.jar文件其命令为:\n\r\r\tsourceanalyzer -b MyProject -cp \"lib/*.jar\" \"src/**/*.java“\n<!--more-->\r\t\r转换文件 myCode.java并指定使用javac编译器其命令为:\n\r\r\tsourceanalyzer -b mybuild –c javac -cp libs.jar MyCode.java\n\nJ2EE项目转换简便方法\n\r把项目的所有文件和库都放在一个目录下,运行下面的命令:\n\r\r\tsourceanalyzer -Xmx1000m -b pName -encoding \"UTF-8\" -cp \"**/*.jar\" .\n\r\t\r\tsourceanalyzer -Xmx1000m -b pName -appserver weblogic -appserver-verion 9 –appserver-home “d:\\bea\\webloigc\\server\\lib” -encoding \"UTF-8\" -cp \"**/*.jar\" .\n\r\t\n\rJava项目扫描实例\n\r\r1 clean\n\r\r\tsourceanalyzer -b eightball -clean\r2 translate\n\r\r\tsourceanalyzer -b eightball -Xmx1250m -jdk 1.5 -debug -cp *.jar .\n\r\t\r3 show -file\n\r\r\tsourceanalyzer -b eightball -show-files\n\r\t\r4 scan\n\r\r\tsourceanalyzer -b eightball -Xmx1250m -debug -scan -f\r\t eightball.fpr -disable-source-rendering\n\r导出 pdf/rtf/xml\n\r\r\tReportGenerator -format [pdf/rtf/xml] -f 生成文件路径 -source fpr文件路径 template \"指定模板.xml\"\n\r\t\n\r以下是我写的一个脚本，用于循环扫描所有工程，每个工程的路径放在fortify_scan_dir_list.txt中\n\r\r\tfortify_result_path=\"/root/fortify\"\n\tsvn_list=\"/root/fortify_scan_dir_list.txt\"\n\n\tfor line in $(<$svn_list)\n\tdo\n\t\ttarge_name=${line##*/}\n\t\techo  ------ $targe_name 开始\n\n\t\techo  -clean-\n\t\tsourceanalyzer -b $targe_name -clean\n\t\techo  -转换-\n\t\tsourceanalyzer -b $targe_name -cp \"$line/**/*.jar\" -source 1.7 -encoding UTF-8 \"$line\"\n\t\tfile_name=$targe_name-`date --date=\"-24 hour\" +%Y%m%d`\n\t\techo  -扫描-\n\t\tsourceanalyzer -b $targe_name -format fpr -f $fortify_result_path/$file_name.fpr -scan\n\t\techo  -生成报告-\n\t\tReportGenerator -format rtf -f $fortify_result_path/$file_name.rtf -source $fortify_result_path/$file_name.fpr template \"Developer Workbook 2014CN.xml\"\n\t\tReportGenerator -format xml -f $fortify_result_path/$file_name.xml -source $fortify_result_path/$file_name.fpr template \"Developer Workbook 2014CN.xml\"\n\t\tReportGenerator -format pdf -f $fortify_result_path/$file_name.pdf -source $fortify_result_path/$file_name.fpr template \"Developer Workbook 2014CN.xml\"\n\n\t\techo ----- $targe_name 结束\n\tdone\n\n----------\n   \n","tags":["fortify"]},{"title":"fortify 安装配置","url":"/2016/03/17/security/fortify 安装配置/","content":"![HP Fortify SCA](http://img.geyuxu.com/2016-03-17-001.png)\n\n<!--more-->\n\n1.安装文件\n\n\tWindows\n\t\n\tLinux\n\t\n\tMac OS X\n\n一路 next...\n\n*以 linux 为例默认安装目录为\n\n\t/opt/HP_Fortify/HP_Fortify_SCA_and_Apps_4.30\n2.将 license 拷贝到默认安装目录下\n\n3.复制规则库\n\n\t*离线规则库在 http://support.fortify.com 中下载\n\t安装目录/Core/config/rules/\n\t\n4.修改配置文件 Core/config/fortify.properties\n\t\n\tcom.fortify.locale=zh_CN\n\n\n----------\n   \n","tags":["fortify"]},{"title":"默默的擦亮手里的武器，准备下一次战斗","url":"/2015/12/24/others/默默的擦亮手里的武器，准备下一次战斗/","content":"\t来自老罗的一个小故事用于自勉\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;光武帝刘秀打仗的时候，有一次吃了败仗，夜里去巡视营房，跑到营房里看看那些战败的士兵是什么心态。结果一看，这个帐篷里几个人，满脸的泪水，哭哭啼啼，写家书的，写情书的。跑到下一个帐篷里一看，几个人喝的醉醺醺的，满脸的眼泪，抱在一块又唱又哭，丑态百出，唱“擦干眼泪陪你睡之类”之类的。走着走着，一路都是这样。终于走到一个帐篷，往里一看，里面坐着一个年轻的将军。他拿着一块破布，不停的擦自己的武器和盔甲，擦的雪亮雪亮的。脸上的表情呢，既不忧伤，也不沮丧；既不愤怒，也不亢奋。很平静，跟没事似的，就在那里擦武器，擦的雪亮雪亮的，准备下一场战斗。刘秀很惊讶，说：“这小子肯定能成事！”结果这小子真的成了事，就是东汉的大将军吴汉。","tags":["老罗语录"]},{"title":"Java中Map转换为指定对象bean","url":"/2015/11/07/java/Java中Map转换为指定对象bean/","content":"\n调用方式：Student stu = BeanUtil.convertMap(Student.class,map);\n\n<!--more-->\n\n\timport java.beans.BeanInfo;\n\timport java.beans.Introspector;\n\timport java.beans.PropertyDescriptor;\n\timport java.lang.reflect.Field;\n\timport java.math.BigDecimal;\n\timport java.util.Date;\n\timport java.util.Map;\n\n\tpublic class BeanUtil{\n\t\tpublic static <T> T convertMap(Class<T> clazz, Map map) {\n          \n            BeanUtil.pretreatment(clazz,map);\n            \n            T obj=null;\n            try {\n                obj = clazz.newInstance(); // 创建 JavaBean 对象\n                BeanInfo beanInfo = Introspector.getBeanInfo(clazz); // 获取类属性\n                // 给 JavaBean 对象的属性赋值\n                PropertyDescriptor[] propertyDescriptors = beanInfo.getPropertyDescriptors();\n                for (int i = 0; i < propertyDescriptors.length; i++) {\n                    PropertyDescriptor descriptor = propertyDescriptors[i];\n                    String propertyName = descriptor.getName();\n                    if (map.containsKey(propertyName)) {\n                        // 下面一句可以 try 起来，这样当一个属性赋值失败的时候就不会影响其他属性赋值。\n                        Object value = map.get(propertyName);\n                        Object[] args = new Object[1];\n                        args[0] = value;\n                        descriptor.getWriteMethod().invoke(obj, args);\n                    }\n                }\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n            return obj;\n        }\n    \n        private static <T> void pretreatment(Class<T> clazz, Map map) {\n    \n            Field[] declaredFields = clazz.getDeclaredFields();\n            for(Field field:declaredFields){\n                String fieldName = field.getName();\n                Object mo = map.get(fieldName);\n                if(mo == null)\n                    continue;\n                if(field.getType() == Date.class){\n                    if(mo instanceof Number){\n                        mo = new Date((Long) mo);\n                    }\n                }else if(Number.class.isAssignableFrom(field.getType())){\n                    if(mo instanceof String || mo instanceof Character) {\n                        if (field.getType() == BigDecimal.class) {\n                            mo = BigDecimal.valueOf(Long.valueOf((String)mo));\n                        }else if(field.getType() == Integer.class){\n                            mo = Integer.valueOf((String)mo);\n                        }else if(field.getType() == Short.class){\n                            mo = Short.valueOf((String)mo);\n                        }\n                    }\n                }\n                map.put(fieldName,mo);\n            }\n        }\n\t}\n\t\n\t\n方法pretreatment作用是预处理类型转换，保证转换不会出错。","tags":["反射"]},{"title":"在 Intellij 中添加mybatis-generator分页插件","url":"/2015/11/02/java/在 Intellij 中添加mybatis-generator分页插件/","content":"mybatis-genreator并没有为我们实现分页操作，本文介绍如何编写mybatis-genreator插件实现分页。\n\n前期工作：在 Intellij 中搭建 mybatis-genreator 环境。\n<!--more-->\n步骤：     \n1.添加插件类\n\n\tpackage com.geyuxu.utils;\n    \n    import org.mybatis.generator.api.CommentGenerator;\n    import org.mybatis.generator.api.IntrospectedTable;\n    import org.mybatis.generator.api.PluginAdapter;\n    import org.mybatis.generator.api.dom.java.*;\n    import org.mybatis.generator.api.dom.xml.Attribute;\n    import org.mybatis.generator.api.dom.xml.Document;\n    import org.mybatis.generator.api.dom.xml.TextElement;\n    import org.mybatis.generator.api.dom.xml.XmlElement;\n    \n    import java.util.List;\n    \n    public class OraclePaginationPlugin extends PluginAdapter {\n        private static String PAGE_URI = \"com.geyuxu.utils.Page\";\n    \n        @Override\n        public boolean modelExampleClassGenerated(TopLevelClass topLevelClass, IntrospectedTable introspectedTable) {\n            addPage(topLevelClass, introspectedTable, \"page\");\n            return super.modelExampleClassGenerated(topLevelClass,\n                    introspectedTable);\n        }\n    \n        @Override\n        public boolean sqlMapDocumentGenerated(Document document,\n                                               IntrospectedTable introspectedTable) {\n            XmlElement parentElement = document.getRootElement();\n    \n            // 产生分页语句前半部分\n            XmlElement paginationPrefixElement = new XmlElement(\"sql\");\n            paginationPrefixElement.addAttribute(new Attribute(\"id\",\n                    \"OracleDialectPrefix\"));\n            XmlElement pageStart = new XmlElement(\"if\");\n            pageStart.addAttribute(new Attribute(\"test\", \"page != null\"));\n            pageStart.addElement(new TextElement(\n                    \"select * from ( select row_.*, rownum rownum_ from ( \"));\n            paginationPrefixElement.addElement(pageStart);\n            parentElement.addElement(paginationPrefixElement);\n    \n            // 产生分页语句后半部分\n            XmlElement paginationSuffixElement = new XmlElement(\"sql\");\n            paginationSuffixElement.addAttribute(new Attribute(\"id\",\n                    \"OracleDialectSuffix\"));\n            XmlElement pageEnd = new XmlElement(\"if\");\n            pageEnd.addAttribute(new Attribute(\"test\", \"page != null\"));\n            pageEnd.addElement(new TextElement(\n                    \"<![CDATA[ ) row_ ) where rownum_ > #{page.begin} and rownum_ <= #{page.end} ]]>\"));\n            paginationSuffixElement.addElement(pageEnd);\n            parentElement.addElement(paginationSuffixElement);\n    \n            return super.sqlMapDocumentGenerated(document, introspectedTable);\n        }\n    \n        @Override\n        public boolean sqlMapSelectByExampleWithoutBLOBsElementGenerated(\n                XmlElement element, IntrospectedTable introspectedTable) {\n    \n            XmlElement pageStart = new XmlElement(\"include\"); //$NON-NLS-1$\n            pageStart.addAttribute(new Attribute(\"refid\", \"OracleDialectPrefix\"));\n            element.getElements().add(0, pageStart);\n    \n            XmlElement isNotNullElement = new XmlElement(\"include\"); //$NON-NLS-1$\n            isNotNullElement.addAttribute(new Attribute(\"refid\",\n                    \"OracleDialectSuffix\"));\n            element.getElements().add(isNotNullElement);\n    \n            return super.sqlMapUpdateByExampleWithoutBLOBsElementGenerated(element,\n                    introspectedTable);\n        }\n    \n        /**\n         * @param topLevelClass\n         * @param introspectedTable\n         * @param name\n         */\n        private void addPage(TopLevelClass topLevelClass,\n                             IntrospectedTable introspectedTable, String name) {\n            topLevelClass.addImportedType(new FullyQualifiedJavaType(\n                    PAGE_URI));\n            CommentGenerator commentGenerator = context.getCommentGenerator();\n            Field field = new Field();\n            field.setVisibility(JavaVisibility.PROTECTED);\n            field.setType(new FullyQualifiedJavaType(PAGE_URI));\n            field.setName(name);\n            commentGenerator.addFieldComment(field, introspectedTable);\n            topLevelClass.addField(field);\n            char c = name.charAt(0);\n            String camel = Character.toUpperCase(c) + name.substring(1);\n            Method method = new Method();\n            method.setVisibility(JavaVisibility.PUBLIC);\n            method.setName(\"set\" + camel);\n            method.addParameter(new Parameter(new FullyQualifiedJavaType(\n                    PAGE_URI), name));\n            method.addBodyLine(\"this.\" + name + \"=\" + name + \";\");\n            commentGenerator.addGeneralMethodComment(method, introspectedTable);\n            topLevelClass.addMethod(method);\n            method = new Method();\n            method.setVisibility(JavaVisibility.PUBLIC);\n            method.setReturnType(new FullyQualifiedJavaType(\n                    PAGE_URI));\n            method.setName(\"get\" + camel);\n            method.addBodyLine(\"return \" + name + \";\");\n            commentGenerator.addGeneralMethodComment(method, introspectedTable);\n            topLevelClass.addMethod(method);\n        }\n    \n        @Override\n        public boolean validate(List<String> list) {\n            return true;\n        }\n    }\n      \n2.添加Page类\n\n\tpackage com.geyuxu.utils;\n    \n    import java.util.List;\n\n    public class Page<T> {\n        // 分页查询开始记录位置\n        private int begin;\n        // 分页查看下结束位置\n        private int end;\n        // 每页显示记录数\n        private int length;\n        // 查询结果总记录数\n        private int count;\n        // 当前页码\n        private int current;\n        // 总共页数\n        private int total;\n    \n        private List<T> list;\n\n    \n        /**\n         * 构造函数\n         */\n    \n        public Page(Integer pageNo) {\n            this(pageNo,10);\n        }\n    \n        public Page(Integer pageNo,Integer length) {\n            this.current = pageNo;\n            this.length = length == null?10:length;\n            this.begin = (this.current - 1) * this.length ;\n            this.end = this.begin + this.length;\n        }\n    \n        /**\n         * @return the begin\n         */\n        public int getBegin() {\n            return begin;\n        }\n    \n        /**\n         * @return the end\n         */\n        public int getEnd() {\n            return end;\n        }\n    \n        /**\n         * @param end the end to set\n         */\n        public void setEnd(int end) {\n            this.end = end;\n        }\n    \n        /**\n         * @param begin the begin to set\n         */\n        public void setBegin(int begin) {\n            this.begin = begin;\n            if (this.length != 0) {\n                this.current = (int) Math.floor((this.begin * 1.0d) / this.length) + 1;\n            }\n        }\n    \n        /**\n         * @return the length\n         */\n        public int getLength() {\n            return length;\n        }\n    \n        /**\n         * @param length the length to set\n         */\n        public void setLength(int length) {\n            this.length = length;\n            if (this.begin != 0) {\n                this.current = (int) Math.floor((this.begin * 1.0d) / this.length) + 1;\n            }\n        }\n    \n        /**\n         * @return the count\n         */\n        public int getCount() {\n            return count;\n        }\n    \n        /**\n         * @param count the count to set\n         */\n        public void setCount(int count) {\n            this.count = count;\n            this.total = (int) Math.floor((this.count * 1.0d) / this.length);\n            if (this.count % this.length != 0) {\n                this.total++;\n            }\n        }\n    \n        /**\n         * @return the current\n         */\n        public int getCurrent() {\n            return current;\n        }\n    \n        /**\n         * @param current the current to set\n         */\n        public void setCurrent(int current) {\n            this.current = current;\n        }\n    \n        /**\n         * @return the total\n         */\n        public int getTotal() {\n            if (total == 0) {\n                return 1;\n            }\n            return total;\n        }\n    \n        /**\n         * @param total the total to set\n         */\n        public void setTotal(int total) {\n            this.total = total;\n        }\n    \n        public List<T> getList() {\n            return list;\n        }\n    \n        public void setList(List<T> list) {\n            this.list = list;\n        }\n    }\n\n3.将OraclePaginationPlugin打成 jar 包\n\n在菜单『File>Project Structure>Artifacts>+(Add)>Jar>Empty』    \nName 设置为pagination-0.1   \nOutput Directory 选择一个合适的目录，我这里选的是桌面『/Users/geyuxu/Desktop』 \n添加一个目录，Directory Content      \n![img](http://img.geyuxu.com/2015-11-02-1.png)    \n选择 生成class 文件所在的目录，我这里是 target/classes\n\n4.将打好的 jar 包导入到 maven 本地库中\nEdit Configurations    \n![img](http://img.geyuxu.com/2015-11-02-2.png)       \nmaven    \n![img](http://img.geyuxu.com/2015-11-02-3.png)       \nname 随便填，Working directory 选当前项目的目录  \n![img](http://img.geyuxu.com/2015-11-02-4.png)      \nCommand line:    \n\n\tinstall:install-file -Dfile=/Users/geyuxu/Desktop/pagination-0.1.jar -DgroupId=com.geyuxu.utils -DartifactId=pagination -Dversion=0.1 -Dpackaging=jar\n \n5.在[]添加如下选项\n![img](http://img.geyuxu.com/2015-11-02-5.png)   \n\n6.修改 pom文件\n\n\t\t</plugins>\n\t\t\t<plugin>\n\t\t\t\t<groupId>org.mybatis.generator</groupId>\n\t\t\t\t<artifactId>mybatis-generator-maven-plugin</artifactId>\n\t\t\t\t<version>1.3.2</version>\n\t\t\t\t<configuration>\n\t\t\t\t\t<verbose>true</verbose>\n\t\t\t\t\t<overwrite>true</overwrite>\n\t\t\t\t</configuration>\n\t\t\t\t<dependencies>\n\t\t\t\t\t<dependency>\n\t\t\t\t\t\t<groupId>com.geyuxu.utils</groupId>\n\t\t\t\t\t\t<artifactId>pagination</artifactId>\n\t\t\t\t\t\t<version>0.1</version>\n\t\t\t\t\t</dependency>\n\t\t\t\t</dependencies>\n\t\t\t</plugin>\n\t\t</plugins>\n\n使用方法：\n\n\tint pageNum = 1;\n\tint pageSize = 10;\n\tStudentExample example = new StudentExample();\n\tPage<Student> page = new Page<Student>(pageNum,pageSize);\n    example.setPage(page);\n    page.setCount(studentMapper.countByExample(example));\n    List<Student> students = studentMapper.selectByExample(example);\n\tpage.setList(students);\n\t\n-----------\n参考资料：    \n[Mybatis Generator实现分页功能](http://blog.csdn.net/aking21alinjuju/article/details/9357893)         \n[mybatis generator生成带有分页的Mybatis代码](http://blog.csdn.net/xzknet/article/details/44158009)    \n[http://bbs.csdn.net/topics/390841395](http://bbs.csdn.net/topics/390841395)    \n[http://www.iteye.com/problems/103171](http://www.iteye.com/problems/103171)    \n[Intellij IDEA 14中使用MyBatis-generator 自动生成MyBatis代码](http://blog.csdn.net/z69183787/article/details/46560071)\n","tags":["genreator"]},{"title":"改进我们的编辑器-使用trigger触发事件","url":"/2015/05/31/nodejs/改进我们的编辑器-使用trigger触发事件/","content":"昨天我终于把我梦寐以求的编辑器写出来了，真是很简约（lou）啊。\n\n![演示](http://img.geyuxu.com/2015-05-31-001.png)\n<!--more-->\n首先我们将package.json中的 toolbar设置为true，这样方便我们调试程序。\n\n这个Choose File按钮实在太丑了，大大的“No file chosen”提示着一些不知所谓的东西，我们先把它换掉。 \n \n![演示](http://img.geyuxu.com/2015-05-31-002.png)\n\n在fileDialog后面添加一行`<a id=\"save\">保存</a>`，然后添加如下脚本\n\n\tvar $fileDialog = $('#fileDialog');\n\t$fileDialog.hide();\n\t\n\t$('#save').click(function(){\n\t\t$fileDialog.trigger('click');\n\t});\n\n首先我们用jquery将fileDialog隐藏掉，然后响应“保存”的点击事件，trigger是jquery用于主动触发事件的函数，`$fileDialog.trigger('click');`相当于点击了Choose File按钮。\n\n![演示](http://img.geyuxu.com/2015-05-31-003.png)","tags":["trigger"]},{"title":"nodejs实现桌面应用-markdown编辑器","url":"/2015/05/30/nodejs/nodejs实现桌面应用-markdown编辑器/","content":"安装node-webkit\n======\n\tnpm install -g nw \n\n\n什么是node-webkit\n===========\nnode-webkit是使用nodejs和Chromium为核心开发桌面软件的技术，我们可以使用html/javascript/css来开发桌面应用的界面，用nodejs技术来开发桌面应用的逻辑业务。  \n<!--more-->\n我们先用`npm init`创建一个package.json文件，随便填或者一路回车就可以。\n修改package.json文件\n\n\t{\n\t  \"name\": \"test1\",\n\t  \"version\": \"0.0.0\",\n\t  \"description\": \"\",\n\t  \"main\": \"index.html\",//这里修改为index.html\n\t  \"scripts\": {\n\t    \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\"\n\t  },\n\t  \"author\": \"\",\n\t  \"license\": \"BSD-2-Clause\"\n\t}\n\n然后创建一个index.html文件，文件内容大概是这样：\n\n\t<!DOCTYPE html>\n\t<html>\n\t  <head>\n\t    <title>test1</title>\n\t  </head>\n\t  <body>\n\t\t<script>document.write('这是我们的第一个nodejs桌面应用');</script>\n\t  </body>\n\t</html>\n\n在shell中运行 `nw .`\n\n![运行的图片](http://img.geyuxu.com/2015-05-30-001.png)\n\n由图我们可以得知，这其实就是一个浏览器。我们需要将导航条去掉，在package.json中加入`\"window:{\"toolbar\":false}\"`\n\n\t{\n\t  \"name\": \"test1\",\n\t  \"version\": \"0.0.0\",\n\t  \"description\": \"\",\n\t  \"main\": \"index.html\",\n\t  \"window\":{\n\t\t\"toolbar\": false\n\t  },\n\t  \"scripts\": {\n\t    \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\"\n\t  },\n\t  \"author\": \"\",\n\t  \"license\": \"BSD-2-Clause\"\n\t}\n\n再次启动`nw .`\n\n![运行的图片](http://img.geyuxu.com/2015-05-30-002.png)\n\n安装markdown-js\n================\n我一直为写markdown而困扰，好用的markdown编辑器收费高昂，且本人是三平台工作（mac/linux/windows），也没有一个好用的跨平台markdown编辑器。自己写一个编辑器的想法早就有，奈何技术复杂并且工作繁忙。但如果使用node-webkit平台去做，这件事将非常简单。markdown-js是nodejs的markdown语法解析器，它可以将markdown直接翻译成html文本。我们要做的无非是将markdown翻译出的html放到一个标签中。  \n安装markdown-js  \n\n\tnpm install markdown\n\n引入markdown模块，并调用markdown.toHTML()方法。\n\n\t<!DOCTYPE html>\n\t<html>\n\t  <head>\n\t    <title>test1</title>\n\t  </head>\n\t  <body>\n\t\t<script>\n\t\t\tvar markdown = require('markdown').markdown;\n\t\t\t\n\t\t\tdocument.write(markdown.toHTML('hello **geyuxu**'));\n\t\t</script>\n\t  </body>\n\t</html>\n\n![运行的图片](http://img.geyuxu.com/2015-05-30-003.png)\t\n\n写一个左右布局的页面\n=================\n至此，我们可以在页面中使用markdown模块了。既然如此，为什么不写一个左右布局的页面。左边嵌套一个文本框作为markdown输入框，右边填入markdown-js转换后的html，这样就可以实现市面上常见的markdown所见即所得编辑器了。\n\n修改index.html\n\n\t<!DOCTYPE html>\n\t<html>\n\t  <head>\n\t    <title>test1</title>\n\t\t<script src=\"./jquery-1.7.1.js\"></script>\n\t\t<style>\n\t\t\t*{font-size:18px;margin:0}\n\t\t\thtml,body{height:100%}\n\t\t\t.left{width:50%;height:100%;float:left;}\n\t\t\t.right{width:50%;height:100%;float:left;}\n\t\t\t.left textarea{width:98%;height:100%;background:transparent;border-style:none;}\n\t\t</style>\n\t  </head>\n\t  <body>\n\t\t<div class=\"left\"><textarea></textarea></div>\n\t\t<div class=\"right\"></div>\n\t\t\n\t\t<script>\n\t\t\t//引入markdown\n\t\t\tvar markdown = require('markdown').markdown;\n\t\t\t\n\t\t\t//相应textarea的keyup事件，当输入字符时刷新右边的效果\t\n\t\t\t$('.left textarea').on('keyup',function(){\n\t\t\t\tvar content = $(this).val();\n\t\t\t\tcontent = markdown.toHTML(content);\n\t\t\t\t$('.right').html(content);\n\t\t\t});\n\t\n\t\t</script>\n\t  </body>\n\t</html>\n\n![运行的图片](http://img.geyuxu.com/2015-05-30-004.png)\t\n\n至此我们的简易markdown编辑器就算完成了，是不是很简单。\n\n用fs模块保存文件\n==================\n引入fs模块`var fs = require('fs');` fs模块是nodejs核心模块，不需要npm install  \n使用`fs.writeFileSync(路径,内容)`就可以保存文件了。\n\n\t<!DOCTYPE html>\n\t<html>\n\t  <head>\n\t    <title>test1</title>\n\t\t<script src=\"./jquery-1.7.1.js\"></script>\n\t\t<style>\n\t\t\t*{font-size:18px;margin:0}\n\t\t\thtml,body{height:100%}\n\t\t\t.left{width:50%;height:100%;float:left;}\n\t\t\t.right{width:50%;height:100%;float:left;}\n\t\t\t.left textarea{width:98%;height:100%;background:transparent;border-style:none;}\n\t\t</style>\n\t  </head>\n\t  <body>\n\t\t<div class=\"left\"><textarea></textarea></div>\n\t\t<div class=\"right\"></div>\n\t\t<input id=\"fileDialog\" type=\"file\" nwsaveas />\n\t\t<script>\n\t\t\tvar markdown = require('markdown').markdown;\n\t\t\tvar fs = require('fs');\t\n\t\t\t\n\t\t\t$(function(){\n\t\t\t\t$('.left textarea').on('keyup',function(){\n\t\t\t\t\tvar content = $(this).val();\n\t\t\t\t\tcontent = markdown.toHTML(content);\n\t\t\t\t\t$('.right').html(content);\n\t\t\t\t});\n\t\t\t\t\n\t\t\t\t//相应file标签的change事件，\n\t\t\t\t$('#fileDialog').on('change',function(){\n\t\t\t\t\tfs.writeFileSync($(this).val(),$('.left textarea').val());\n\t\t\t\t\t$(this).val(\"\");\n\t\t\t\t});\n\t\t\t});\n\t\t\t\n\t\n\t\t</script>\n\t  </body>\n\t</html>\n\n`<input id=\"fileDialog\" type=\"file\" nwsaveas />` node0-webkit对html做了扩展，`nsaveas`会弹出一个保存对话框。\n\n将程序打包成exe\n=========\n将我们程序的所有文件缩成一个zip文件  \n![运行的图片](http://img.geyuxu.com/2015-05-30-005.png)\t\n\n打开nodejs安装目录，找到nw所在目录，将zip文件拷贝到nwjs下  \n![运行的图片](http://img.geyuxu.com/2015-05-30-006.png)\n\n在cmd中用`copy /b`命令将nw.exe和test1.zip合并成一个可执行文件\n\n\t>copy /b nw.exe+test1.zip test1.exe\n![运行的图片](http://img.geyuxu.com/2015-05-30-007.png)\n\n注意，nw.exe必须在前面。\n\n![运行的图片](http://img.geyuxu.com/2015-05-30-008.png)\n\n双击test1.exe就可以运行了，这时test1.exe还不能单独运行，它需要依赖dll文件。我们可以用[Enigma Virtual Box](http://enigmaprotector.com/assets/files/enigmavb.exe)将所有需要的dll文件打包。\n![运行的图片](http://img.geyuxu.com/2015-05-30-009.png)\n点击Process之后，生成的test1_boxed.exe，就可以单独拷贝出去运行了。\n\n---------------\n参考：\n> [node-webkit中文文档](http://www.xuanhun521.com/?search=node)  \n> [www.cnblogs.com/xuanhun/p/3653816.html](http://www.cnblogs.com/xuanhun/p/3653816.html)  \n> [node-webkit官方网站](https://github.com/nwjs/nw.js)  \n> [node-webkit：开发桌面+WEB混合型应用的神器](http://damoqiongqiu.iteye.com/blog/2010720)","tags":["markdown"]},{"title":"看、做、想","url":"/2015/05/30/others/看、做、想/","content":"不仅仅是设计，各行各业是相通的。你想要成为一个优秀的软件工程师，就需要阅读大量优秀的开源代码，去参与各种项目，更重要是去总结经验。你需要与更牛人站在一起，而不是与你一样的人混日子。\n\n<embed src=\"http://player.youku.com/player.php/sid/XOTU4NzE4NTQ4/v.swf\" allowFullScreen=\"true\" quality=\"high\" width=\"480\" height=\"400\" align=\"middle\" allowScriptAccess=\"always\" type=\"application/x-shockwave-flash\"></embed>\n","tags":["ted"]},{"title":"npm使用国内镜像","url":"/2015/05/28/nodejs/npm使用国内镜像/","content":"切换方法\n-------\n方法一：在命令上指定\n\n\tnpm --registry http://registry.npm.taobao.org\n\n方法二：通过config命令\n\n\tnpm config set registry http://registry.npm.taobao.org\n\n方法三：编辑 [User Home]/.npmrc 加入下面内容，此方法同方法二等效\n\n\tregistry = http://registry.npm.taobao.org\n<!--more-->\n国内镜像\n-------\n淘宝镜像：[http://registry.npm.taobao.org](http://registry.npm.taobao.org)\n\ncnpmjs：[http://registry.cnpmjs.org](http://registry.cnpmjs.org)\n\n\nnpm publish\n-----------\nnpm publish命令会发布你自己的模块到npm社区，所以在使用该命令前要切换回原先的registry：https://registry.npmjs.org\n\n参考：\n\n[http://cnpmjs.org/](http://cnpmjs.org/)\n\n[http://npm.taobao.org/](http://npm.taobao.org/)","tags":["registry"]},{"title":"HTTP协议详解","url":"/2015/05/24/reproduce/HTTP协议详解/","content":"原文：[HTTP协议详解](http://blog.csdn.net/gueter/article/details/1524447)\n\n作者 :Jeffrey  \n引言 \n------                                         \nHTTP是一个属于应用层的面向对象的协议，由于其简捷、快速的方式，适用于分布式超媒体信息系统。它于1990年提出，经过几年的使用与发展，得到不断地完善和扩展。目前在WWW中使用的是HTTP/1.0的第六版，HTTP/1.1的规范化工作正在进行之中，而且HTTP-NG(Next Generation of HTTP)的建议已经提出。  \n<!--more-->\nHTTP协议的主要特点可概括如下：  \n1.支持客户/服务器模式。  \n2.简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。每种方法规定了客户与服务器联系的类型不同。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。  \n3.灵活：HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记。  \n4.无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。  \n5.无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。\n\n \n一、HTTP协议详解之URL篇\n------  \nhttp（超文本传输协议）是一个基于请求与响应模式的、无状态的、应用层的协议，常基于TCP的连接方式，HTTP1.1版本中给出一种持续连接的机制，绝大多数的Web开发，都是构建在HTTP协议之上的Web应用。\n\nHTTP URL (URL是一种特殊类型的URI，包含了用于查找某个资源的足够的信息)的格式如下：  \n\n\thttp://host[\":\"port][abs_path]\n\nhttp表示要通过HTTP协议来定位网络资源；host表示合法的Internet主机域名或者IP地址；port指定一个端口号，为空则使用缺省端口80；abs_path指定请求资源的URI；如果URL中没有给出abs_path，那么当它作为请求URI时，必须以“/”的形式给出，通常这个工作浏览器自动帮我们完成。  \neg:  \n\n\t1、输入：www.guet.edu.cn\n\t浏览器自动转换成：http://www.guet.edu.cn/\n\t2、http:192.168.0.116:8080/index.jsp \n\n \n\n \n\n \n\n二、HTTP协议详解之请求篇\n------  \nhttp请求由三部分组成，分别是：请求行、消息报头、请求正文\n\n1、请求行以一个方法符号开头，以空格分开，后面跟着请求的URI和协议的版本，格式如下：Method Request-URI HTTP-Version CRLF  \n其中 Method表示请求方法；Request-URI是一个统一资源标识符；HTTP-Version表示请求的HTTP协议版本；CRLF表示回车和换行（除了作为结尾的CRLF外，不允许出现单独的CR或LF字符）。\n\n请求方法（所有方法全为大写）有多种，各个方法的解释如下：        \nGET     请求获取Request-URI所标识的资源  \nPOST    在Request-URI所标识的资源后附加新的数据  \nHEAD    请求获取由Request-URI所标识的资源的响应消息报头  \nPUT     请求服务器存储一个资源，并用Request-URI作为其标识  \nDELETE  请求服务器删除Request-URI所标识的资源  \nTRACE   请求服务器回送收到的请求信息，主要用于测试或诊断  \nCONNECT 保留将来使用  \nOPTIONS 请求查询服务器的性能，或者查询与资源相关的选项和需求  \n应用举例：  \nGET方法：在浏览器的地址栏中输入网址的方式访问网页时，浏览器采用GET方法向服务器获取资源，eg:GET /form.html HTTP/1.1 (CRLF)\n\nPOST方法要求被请求服务器接受附在请求后面的数据，常用于提交表单。  \neg：POST /reg.jsp HTTP/ (CRLF)  \nAccept:image/gif,image/x-xbit,... (CRLF)  \n...  \nHOST:www.guet.edu.cn (CRLF)  \nContent-Length:22 (CRLF)  \nConnection:Keep-Alive (CRLF)  \nCache-Control:no-cache (CRLF)  \n(CRLF)         //该CRLF表示消息报头已经结束，在此之前为消息报头  \nuser=jeffrey&pwd=1234  //此行以下为提交的数据    \n\nHEAD方法与GET方法几乎是一样的，对于HEAD请求的回应部分来说，它的HTTP头部中包含的信息与通过GET请求所得到的信息是相同的。利用这个方法，不必传输整个资源内容，就可以得到Request-URI所标识的资源的信息。该方法常用于测试超链接的有效性，是否可以访问，以及最近是否更新。  \n2、请求报头后述  \n3、请求正文(略) \n\n \n\n三、HTTP协议详解之响应篇\n------  \n在接收和解释请求消息后，服务器返回一个HTTP响应消息。\n\nHTTP响应也是由三个部分组成，分别是：状态行、消息报头、响应正文  \n1、状态行格式如下：  \nHTTP-Version Status-Code Reason-Phrase CRLF  \n其中，HTTP-Version表示服务器HTTP协议的版本；Status-Code表示服务器发回的响应状态代码；Reason-Phrase表示状态代码的文本描述。  \n状态代码有三位数字组成，第一个数字定义了响应的类别，且有五种可能取值：  \n1xx：指示信息--表示请求已接收，继续处理  \n2xx：成功--表示请求已被成功接收、理解、接受  \n3xx：重定向--要完成请求必须进行更进一步的操作  \n4xx：客户端错误--请求有语法错误或请求无法实现  \n5xx：服务器端错误--服务器未能实现合法的请求  \n常见状态代码、状态描述、说明：  \n200 OK      //客户端请求成功  \n400 Bad Request  //客户端请求有语法错误，不能被服务器所理解  \n401 Unauthorized //请求未经授权，这个状态代码必须和WWW-Authenticate报                 //头域一起使用   \n403 Forbidden  //服务器收到请求，但是拒绝提供服务  \n404 Not Found  //请求资源不存在，eg：输入了错误的URL  \n500 Internal Server Error //服务器发生不可预期的错误  \n503 Server Unavailable  //服务器当前不能处理客户端的请求，一段时间后，                         //可能恢复正常  \neg：HTTP/1.1 200 OK （CRLF）\n\n2、响应报头后述\n\n3、响应正文就是服务器返回的资源的内容 \n\n \n\n四、HTTP协议详解之消息报头篇\n-------------------------\nHTTP消息由客户端到服务器的请求和服务器到客户端的响应组成。请求消息和响应消息都是由开始行（对于请求消息，开始行就是请求行，对于响应消息，开始行就是状态行），消息报头（可选），空行（只有CRLF的行），消息正文（可选）组成。\n\nHTTP消息报头包括普通报头、请求报头、响应报头、实体报头。    \n每一个报头域都是由名字+“：”+空格+值 组成，消息报头域的名字是大小写无关的。  \n\n1、普通报头  \n在普通报头中，有少数报头域用于所有的请求和响应消息，但并不用于被传输的实体，只用于传输的消息。  \neg：  \nCache-Control   用于指定缓存指令，缓存指令是单向的（响应中出现的缓存指令在请求中未必会出现），且是独立的（一个消息的缓存指令不会影响另一个消息处理的缓存机制），HTTP1.0使用的类似的报头域为Pragma。  \n请求时的缓存指令包括：no-cache（用于指示请求或响应消息不能缓存）、no-store、max-age、max-stale、min-fresh、only-if-cached;  \n响应时的缓存指令包括：public、private、no-cache、no-store、no-transform、must-revalidate、proxy-revalidate、max-age、s-maxage.  \neg：为了指示IE浏览器（客户端）不要缓存页面，服务器端的JSP程序可以编写如下：response.sehHeader(\"Cache-Control\",\"no-cache\");  \n//response.setHeader(\"Pragma\",\"no-cache\");作用相当于上述代码，通常两者//合用  \n这句代码将在发送的响应消息中设置普通报头域：Cache-Control:no-cache\n\n\nDate普通报头域表示消息产生的日期和时间\n\nConnection普通报头域允许发送指定连接的选项。例如指定连接是连续，或者指定“close”选项，通知服务器，在响应完成后，关闭连接\n\n2、请求报头  \n请求报头允许客户端向服务器端传递请求的附加信息以及客户端自身的信息。  \n常用的请求报头  \nAccept  \nAccept请求报头域用于指定客户端接受哪些类型的信息。eg：Accept：image/gif，表明客户端希望接受GIF图象格式的资源；Accept：text/html，表明客户端希望接受html文本。  \nAccept-Charset  \nAccept-Charset请求报头域用于指定客户端接受的字符集。eg：Accept-Charset:iso-8859-1,gb2312.如果在请求消息中没有设置这个域，缺省是任何字符集都可以接受。  \nAccept-Encoding  \nAccept-Encoding请求报头域类似于Accept，但是它是用于指定可接受的内容编码。eg：Accept-Encoding:gzip.deflate.如果请求消息中没有设置这个域服务器假定客户端对各种内容编码都可以接受。  \nAccept-Language   \nAccept-Language请求报头域类似于Accept，但是它是用于指定一种自然语言。eg：Accept-Language:zh-cn.如果请求消息中没有设置这个报头域，服务器假定客户端对各种语言都可以接受。  \nAuthorization  \nAuthorization请求报头域主要用于证明客户端有权查看某个资源。当浏览器访问一个页面时，如果收到服务器的响应代码为401（未授权），可以发送一个包含Authorization请求报头域的请求，要求服务器对其进行验证。  \nHost（发送请求时，该报头域是必需的）  \nHost请求报头域主要用于指定被请求资源的Internet主机和端口号，它通常从HTTP URL中提取出来的，eg：   \n我们在浏览器中输入：http://www.guet.edu.cn/index.html   \n浏览器发送的请求消息中，就会包含Host请求报头域，如下：   \nHost：www.guet.edu.cn   \n此处使用缺省端口号80，若指定了端口号，则变成：Host：www.guet.edu.cn:指定端口号   \nUser-Agent   \n我们上网登陆论坛的时候，往往会看到一些欢迎信息，其中列出了你的操作系统的名称和版本，你所使用的浏览器的名称和版本，这往往让很多人感到很神奇，实际上，服务器应用程序就是从User-Agent这个请求报头域中获取到这些信息。User-Agent请求报头域允许客户端将它的操作系统、浏览器和其它属性告诉服务器。不过，这个报头域不是必需的，如果我们自己编写一个浏览器，不使用User-Agent请求报头域，那么服务器端就无法得知我们的信息了。   \n请求报头举例：    \nGET /form.html HTTP/1.1 (CRLF)    \nAccept:image/gif,image/x-xbitmap,image/jpeg,application/x-shockwave-flash,application/vnd.ms-excel,application/vnd.ms-powerpoint,application/msword,*/* (CRLF)    \nAccept-Language:zh-cn (CRLF)    \nAccept-Encoding:gzip,deflate (CRLF)    \nIf-Modified-Since:Wed,05 Jan 2007 11:21:25 GMT (CRLF)    \nIf-None-Match:W/\"80b1a4c018f3c41:8317\" (CRLF)    \nUser-Agent:Mozilla/4.0(compatible;MSIE6.0;Windows NT 5.0) (CRLF)    \nHost:www.guet.edu.cn (CRLF)    \nConnection:Keep-Alive (CRLF)    \n(CRLF)\n\n3、响应报头    \n响应报头允许服务器传递不能放在状态行中的附加响应信息，以及关于服务器的信息和对Request-URI所标识的资源进行下一步访问的信息。    \n常用的响应报头    \nLocation    \nLocation响应报头域用于重定向接受者到一个新的位置。Location响应报头域常用在更换域名的时候。    \nServer    \nServer响应报头域包含了服务器用来处理请求的软件信息。与User-Agent请求报头域是相对应的。下面是     \nServer响应报头域的一个例子：    \nServer：Apache-Coyote/1.1     \nWWW-Authenticate    \nWWW-Authenticate响应报头域必须被包含在401（未授权的）响应消息中，客户端收到401响应消息时候，并发送Authorization报头域请求服务器对其进行验证时，服务端响应报头就包含该报头域。    \neg：WWW-Authenticate:Basic realm=\"Basic Auth Test!\"  //可以看出服务器对请求资源采用的是基本验证机制。\n\n\n4、实体报头    \n请求和响应消息都可以传送一个实体。一个实体由实体报头域和实体正文组成，但并不是说实体报头域和实体正文要在一起发送，可以只发送实体报头域。实体报头定义了关于实体正文（eg：有无实体正文）和请求所标识的资源的元信息。    \n常用的实体报头    \nContent-Encoding    \nContent-Encoding实体报头域被用作媒体类型的修饰符，它的值指示了已经被应用到实体正文的附加内容的编码，因而要获得Content-Type报头域中所引用的媒体类型，必须采用相应的解码机制。Content-Encoding这样用于记录文档的压缩方法，eg：Content-Encoding：gzip    \nContent-Language    \nContent-Language实体报头域描述了资源所用的自然语言。没有设置该域则认为实体内容将提供给所有的语言阅读     \n者。eg：Content-Language:da    \nContent-Length    \nContent-Length实体报头域用于指明实体正文的长度，以字节方式存储的十进制数字来表示。     \nContent-Type    \nContent-Type实体报头域用语指明发送给接收者的实体正文的媒体类型。eg：    \nContent-Type:text/html;charset=ISO-8859-1     \nContent-Type:text/html;charset=GB2312     \nLast-Modified     \nLast-Modified实体报头域用于指示资源的最后修改日期和时间。     \nExpires    \nExpires实体报头域给出响应过期的日期和时间。为了让代理服务器或浏览器在一段时间以后更新缓存中(再次访问曾访问过的页面时，直接从缓存中加载，缩短响应时间和降低服务器负载)的页面，我们可以使用Expires实体报头域指定页面过期的时间。eg：Expires：Thu，15 Sep 2006 16:23:12 GMT     \nHTTP1.1的客户端和缓存必须将其他非法的日期格式（包括0）看作已经过期。eg：为了让浏览器不要缓存页面，我们也可以利用Expires实体报头域，设置为0，jsp中程序如下：response.setDateHeader(\"Expires\",\"0\");      \n\n \n\n \n\n五、利用telnet观察http协议的通讯过程   \n----------------------------------  \n实验目的及原理：    \n利用MS的telnet工具，通过手动输入http请求信息的方式，向服务器发出请求，服务器接收、解释和接受请求后，会返回一个响应，该响应会在telnet窗口上显示出来，从而从感性上加深对http协议的通讯过程的认识。\n\n实验步骤：\n\n1、打开telnet    \n1.1 打开telnet    \n运行-->cmd-->telnet   \n\n1.2 打开telnet回显功能    \nset localecho\n\n2、连接服务器并发送请求    \n2.1 open www.guet.edu.cn 80  //注意端口号不能省略   \n\n    HEAD /index.asp HTTP/1.0\n    Host:www.guet.edu.cn\n    \n   /*我们可以变换请求方法,请求桂林电子主页内容,输入消息如下*/\n    open www.guet.edu.cn 80 \n   \n    GET /index.asp HTTP/1.0  //请求资源的内容\n    Host:www.guet.edu.cn  \n\n2.2 open www.sina.com.cn 80  //在命令提示符号下直接输入telnet www.sina.com.cn 80\n    HEAD /index.asp HTTP/1.0\n    Host:www.sina.com.cn\n \n\n3 实验结果：\n\n3.1 请求信息2.1得到的响应是:\n\n\t\tHTTP/1.1 200 OK                                              //请求成功\n\t\tServer: Microsoft-IIS/5.0                                    //web服务器\n\t\tDate: Thu,08 Mar 200707:17:51 GMT\n\t\tConnection: Keep-Alive                                 \n\t\tContent-Length: 23330\n\t\tContent-Type: text/html\n\t\tExpries: Thu,08 Mar 2007 07:16:51 GMT\n\t\tSet-Cookie: ASPSESSIONIDQAQBQQQB=BEJCDGKADEDJKLKKAJEOIMMH; path=/\n\t\tCache-control: private\n\t\n\t\t//资源内容省略\n\n3.2 请求信息2.2得到的响应是:\n\n\tHTTP/1.0 404 Not Found       //请求失败\n\tDate: Thu, 08 Mar 2007 07:50:50 GMT\n\tServer: Apache/2.0.54 <Unix>\n\tLast-Modified: Thu, 30 Nov 2006 11:35:41 GMT\n\tETag: \"6277a-415-e7c76980\"\n\tAccept-Ranges: bytes\n\tX-Powered-By: mod_xlayout_jh/0.0.1vhs.markII.remix\n\tVary: Accept-Encoding\n\tContent-Type: text/html\n\tX-Cache: MISS from zjm152-78.sina.com.cn\n\tVia: 1.0 zjm152-78.sina.com.cn:80<squid/2.6.STABLES-20061207>\n\tX-Cache: MISS from th-143.sina.com.cn\n\tConnection: close\n\n\n\t失去了跟主机的连接\n\n\t按任意键继续...\n\n\n4 .注意事项：  \n\t1.\t出现输入错误，则请求不会成功。  \n\t2. 报头域不分大小写。  \n\t3. 更深一步了解HTTP协议，可以查看RFC2616，在http://www.letf.org/rfc上找到该文件。   \n\t4. 开发后台程序必须掌握http协议 \n\n \n\n六、HTTP协议相关技术补充\n------  \n1、基础：   \n高层协议有：文件传输协议FTP、电子邮件传输协议SMTP、域名系统服务DNS、网络新闻传输协议NNTP和HTTP协议等   \n中介由三种：代理(Proxy)、网关(Gateway)和通道(Tunnel)，一个代理根据URI的绝对格式来接受请求，重写全部或部分消息，通过 URI的标识把已格式化过的请求发送到服务器。网关是一个接收代理，作为一些其它服务器的上层，并且如果必须的话，可以把请求翻译给下层的服务器协议。一 个通道作为不改变消息的两个连接之间的中继点。当通讯需要通过一个中介(例如：防火墙等)或者是中介不能识别消息的内容时，通道经常被使用。   \n 代理(Proxy)：一个中间程序，它可以充当一个服务器，也可以充当一个客户机，为其它客户机建立请求。请求是通过可能的翻译在内部或经过传递到其它的 服务器中。一个代理在发送请求信息之前，必须解释并且如果可能重写它。代理经常作为通过防火墙的客户机端的门户，代理还可以作为一个帮助应用来通过协议处 理没有被用户代理完成的请求。    \n网关(Gateway)：一个作为其它服务器中间媒介的服务器。与代理不同的是，网关接受请求就好象对被请求的资源来说它就是源服务器；发出请求的客户机并没有意识到它在同网关打交道。   \n　　网关经常作为通过防火墙的服务器端的门户，网关还可以作为一个协议翻译器以便存取那些存储在非HTTP系统中的资源。    \n通道(Tunnel)：是作为两个连接中继的中介程序。一旦激活，通道便被认为不属于HTTP通讯，尽管通道可能是被一个HTTP请求初始化的。当被中继 的连接两端关闭时，通道便消失。当一个门户(Portal)必须存在或中介(Intermediary)不能解释中继的通讯时通道被经常使用。    \n\n\n2、协议分析的优势—HTTP分析器检测网络攻击   \n以模块化的方式对高层协议进行分析处理，将是未来入侵检测的方向。    \nHTTP及其代理的常用端口80、3128和8080在network部分用port标签进行了规定    \n\n3、HTTP协议Content Lenth限制漏洞导致拒绝服务攻击   \n使用POST方法时，可以设置ContentLenth来定义需要传送的数据长度，例如ContentLenth:999999999，在传送完成前，内 存不会释放，攻击者可以利用这个缺陷，连续向WEB服务器发送垃圾数据直至WEB服务器内存耗尽。这种攻击方法基本不会留下痕迹。     \nhttp://www.cnpaf.net/Class/HTTP/0532918532667330.html    \n\n\n4、利用HTTP协议的特性进行拒绝服务攻击的一些构思    \n服务器端忙于处理攻击者伪造的TCP连接请求而无暇理睬客户的正常请求（毕竟客户端的正常请求比率非常之小），此时从正常客户的角度看来，服务器失去响应，这种情况我们称作：服务器端受到了SYNFlood攻击（SYN洪水攻击）。   \n而Smurf、TearDrop等是利用ICMP报文来Flood和IP碎片攻击的。本文用“正常连接”的方法来产生拒绝服务攻击。    \n19端口在早期已经有人用来做Chargen攻击了，即Chargen_Denial_of_Service，但是！他们用的方法是在两台Chargen 服务器之间产生UDP连接，让服务器处理过多信息而DOWN掉，那么，干掉一台WEB服务器的条件就必须有2个：1.有Chargen服务2.有HTTP 服务\n方法：攻击者伪造源IP给N台Chargen发送连接请求（Connect），Chargen接收到连接后就会返回每秒72字节的字符流（实际上根据网络实际情况，这个速度更快）给服务器。  \n\n\n5、Http指纹识别技术\nHttp指纹识别的原理大致上也是相同的：记录不同服务器对Http协议执行中的微小差别进行识别.Http指纹识别比TCP/IP堆栈指纹识别复杂许 多,理由是定制Http服务器的配置文件、增加插件或组件使得更改Http的响应信息变的很容易,这样使得识别变的困难；然而定制TCP/IP堆栈的行为 需要对核心层进行修改,所以就容易识别.    \n要让服务器返回不同的Banner信息的设置是很简单的,象Apache这样的开放源代码的Http服务器,用户可以在源代码里修改Banner信息,然 后重起Http服务就生效了；对于没有公开源代码的Http服务器比如微软的IIS或者是Netscape,可以在存放Banner信息的Dll文件中修 改,相关的文章有讨论的,这里不再赘述,当然这样的修改的效果还是不错的.另外一种模糊Banner信息的方法是使用插件。\n常用测试请求：    \n1：HEAD/Http/1.0发送基本的Http请求    \n2：DELETE/Http/1.0发送那些不被允许的请求,比如Delete请求   \n3：GET/Http/3.0发送一个非法版本的Http协议请求    \n4：GET/JUNK/1.0发送一个不正确规格的Http协议请求   \nHttp指纹识别工具Httprint,它通过运用统计学原理,组合模糊的逻辑学技术,能很有效的确定Http服务器的类型.它可以被用来收集和分析不同Http服务器产生的签名。   \n\n\n6、其他：为了提高用户使用浏览器时的性能，现代浏览器还支持并发的访问方式，浏览一个网页时同时建立多个连接，以迅速获得一个网页上的多个图标，这样能更快速完成整个网页的传输。    \nHTTP1.1中提供了这种持续连接的方式，而下一代HTTP协议：HTTP-NG更增加了有关会话控制、丰富的内容协商等方式的支持，来提供\n更高效率的连接。   ","tags":["转载"]},{"title":"nodejs调用dnspodApi","url":"/2015/05/23/nodejs/nodejs调用dnspodApi/","content":"dnspod是国内的一款DNS产品，关于它的介绍请自行搜索，本文（系列）讲的是如何使用nodejs调用dnspod提供的api实现ddns功能。\n\n<!--more-->\t\t\n\tvar https = require('https');\n\tvar querystring = require('querystring');\n\n\tvar post_data = querystring.stringify({\n\t\tlogin_token:'token',\n\t\tformat:'json',// 返回的数据格式，可选，默认为xml，建议用json\n\t\tlang:'cn'//返回的错误语言，可选，默认为en，建议用cn\n\t\terror_on_empty:'yes' //{yes,no} 没有数据时是否返回错误，可选，默认为yes，建议用no\n\t});\n\n\tvar options = {\n\t  hostname: 'dnsapi.cn',\n\t  port: 443,\n\t  path: '/Info.Version',\n\t  method: 'POST',\n\t  headers: {\"Content-type\": \"application/x-www-form-urlencoded\", \"Accept\": \"text/json\", \"User-Agent\": \"geyuxu-nodejs/0.0.1(register@geyuxu.com)\"}\n\t};\n\t\n\tvar req = https.request(options, function(res) {\n\t  console.log(\"statusCode: \", res.statusCode);\n\t  console.log(\"headers: \", res.headers);\n\t\n\t  res.on('data', function(d) {\n\t    process.stdout.write(d);\n\t  });\n\t}).on('error', function(e) {\n\t  console.error(e);\n\t});\n\t\n\treq.write(post_data);\n\nlogin_token Token,如果由此配置，则不需要配置用户账号和用户密码  \nlogin_email 用户帐号，必选  \nlogin_password 用户密码，必选  \nformat {json,xml} 返回的数据格式，可选，默认为xml，建议用json  \nlang {en,cn} 返回的错误语言，可选，默认为en，建议用cn  \nerror_on_empty {yes,no} 没有数据时是否返回错误，可选，默认为yes，建议用no  \nuser_id 用户的ID，可选，仅代理接口需要， 用户接口不需要提交此参数\n\n\n官方文档要求必须写上User-Agent，User-Agent原本是浏览器的标识，如`Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 6.0)`,dnspod要求的格式为`程序英文名称/版本(联系邮箱)`。\n\n必须为POST请求，GET请求会提示错误。\n\n-----------------------------\n参考：\n>[nodejs官方文档](https://support.dnspod.cn/Support/api)\n\n>[dnspod官方api文档](https://support.dnspod.cn/Support/api)\n\n>[dnspod官方python调用demo](https://github.com/DNSPod/dnspod-python)","tags":["api"]},{"title":"nodejs发送https请求","url":"/2015/05/23/nodejs/nodejs发送https请求/","content":"\tvar https = require('https');\n\t\n\thttps.request({\n\t  hostname: 'nodejs.org',\n\t  port: 443,\n\t  path: '/api/https.html',\n\t  method: 'GET'\n\t}, function(res) {\n\t  console.log(\"statusCode: \", res.statusCode);\n\t  console.log(\"headers: \", res.headers);\n\t\n\t  res.on('data', function(d) {\n\t    process.stdout.write(d);\n\t  });\n\t}).on('error', function(e) {\n\t  console.error(e);\n\t}).end();\n\n<!--more-->\nhostname: hostname\n\nport: 端口号，默认是443\n\nmethod: 请求方式，值为POST/GET/PUT...，默认是GET\n\npath: 路径。默认是 '/'. 栗子： '/index.html?page=2'\n\n####发送POST请求：\n\n\tvar https = require('https');\n\tvar querystring = require('querystring');\n\t\n\t\n\tvar post_data = querystring.stringify({\n\t\t//post数据，这里传入json对象\n\t\taaa:'AAA',\n\t\tbbb:'BBB'\n\t});\n\t\n\tvar options = {\n\t  hostname: 'hostname',\n\t  port: 443,\n\t  path: '/',\n\t  method: 'POST',\n\t  headers: {\"Content-type\": \"application/x-www-form-urlencoded\", \"Accept\": \"text/json\",\"User-Agent\": \"geyuxu-nodejs/1.0.0\"}\n\t};\n\t\n\tvar req = https.request(options, function(res) {\n\t  console.log(\"statusCode: \", res.statusCode);\n\t  console.log(\"headers: \", res.headers);\n\t\n\t  res.on('data', function(d) {\n\t    process.stdout.write(d);\n\t  });\n\t}).on('error', function(e) {\n\t  console.error(e);\n\t});\n\t\n\treq.write(post_data);\n\treq.end();\n\npost请求数据需要用querystring包的stringify方法，将json对象转换为请求字符串`aaa=AAA&bbb=BBB`\n\nreq.write(post_data);将post数据传到服务器\n\n------------------\n参考：\n\n>[官方文档](https://nodejs.org/api/https.html)\n\n\n","tags":["https"]},{"title":"自定义注解+SpringAop实现参数绑定","url":"/2015/05/23/java/自定义注解+SpringAop实现参数绑定/","content":"\n实现自定义注解@RequestBodyMap，以下是我们的调用demo。\n\n\t@RequestMapping(value = \"/test.htm\", method = RequestMethod.POST)\n\t@ResponseBody\n\tpublic Person test(HttpServletRequest request,@RequestBodyMap Person person) {\n\t\t//操作\n\t\treturn person;\n\t}\n<!--more-->\n加了@RequestBodyMap注解的person会自动绑定浏览器传过来的数据，包括json、map、xml等。\n\n@RequestBodyMap.java:\n\n\t...\n\t@Target(ElementType.PARAMETER)\n\t@Retention(RetentionPolicy.RUNTIME)\n\t@Documented\n\tpublic @interface RequestBodyMap {\n\t\n\t}\n\t...\n\n\n@Target说明了Annotation所修饰的对象范围：包、类、字段、方法等  \n取值有：  \n1. ElementType.CONSTRUCTOR:用于描述构造器  \n2. ElementType.FIELD:用于描述域  \n3. ElementType.LOCAL_VARIABLE:用于描述局部变量  \n4. ElementType.METHOD:用于描述方法  \n5. ElementType.PACKAGE:用于描述包  \n6. ElementType.PARAMETER:用于描述参数  \n7. ElementType.TYPE:用于描述类、接口(包括注解类型) 或enum声明  \n\n@Retention定义了该Annotation被保留的时间长短：  \n1. RetentionPolicy.SOURCE：仅出现在源代码中，而被编译器丢弃  \n2. RetentionPolicy.CLASS：编译在class文件中，运行时不被保留；   \n3. RetentionPolicy.RUNTIME：运行时保留；\n\n\n\n@Documented用于描述其它类型的annotation应该被作为被标注的程序成员的公共API，因此可以被例如javadoc此类的工具文档化。Documented是一个标记注解，没有成员。\n\n@Inherited阐述了某个被标注的类型是被继承的。如果一个使用了@Inherited修饰的annotation类型被用于一个class，则这个annotation将被用于该class的子类。\n\nConverterInterceptor.java:\n\t\n\t...\n\t@Aspect\n\tpublic class ConverterInterceptor {\n\t\t\n\t\t/**\n\t\t * 定义一个切入点\n\t\t */\n\t\t@Pointcut(\"(execution(* com.geyuxu.*.*(..)))\")  \n\t    private void anyMethod(){}  \n\t      \n\t    /**\n\t     * 方法描述：  \n\t     * 注入带RequestBodyMap注解的参数\n\t     * 1、判断参数中是否有RequestBodyMap注解<br/>\n\t     * 2、将json或map转换成对象<br/>\n\t     * 3、执行方法<br/>\n\t     * @Title: doBasicProfiling \n\t     * @date 2015年5月21日 下午7:17:35\n\t     * @author 葛于旭\n\t     * @modifier \n\t     * @modifydate \n\t     * @param pjp\n\t     * @return\n\t     * @throws Throwable\n\t     */\n\t    @Around(\"anyMethod()\")  \n\t    public Object doBasicProfiling(ProceedingJoinPoint pjp) throws Throwable{  \n\t\n\t\t\t/**\n\t\t\t * 获取参数注解\n\t\t\t */\n\t    \tMethodSignature signature = (MethodSignature) pjp.getSignature();\n\t    \tMethod method = signature.getMethod();\n\t    \tAnnotation[][] annss = method.getParameterAnnotations();\n\t\n\t\t\t/**\n\t\t\t * 判断参数中是否有注解\n\t\t\t */\n\t    \tint idx = 0;\n\t    \tloop:for(Annotation[] anns : annss){\n\t    \t\tfor(Annotation ann : anns){\n\t    \t\t\tif(ann instanceof RequestBodyMap){\n\t    \t\t\t\tbreak loop;\n\t    \t\t\t}\n\t    \t\t} \n\t    \t\tidx++;\n\t    \t}\n\t    \t\n\t    \tObject object = null;\n\t    \t\n\t    \tif(idx != annss.length){\n\t    \t\tObject[] args = pjp.getArgs();\n\t        \tHttpServletRequest request = (HttpServletRequest) args[0];\n\t        \t\n\t        \t@SuppressWarnings(\"rawtypes\")\n\t    \t\tClass[] clazzs = method.getParameterTypes();\n\t        \t\n\t\t\t\t//此方法自己实现，根据请求头决定如何转换对象\n\t        \t@SuppressWarnings(\"unchecked\")\n\t\t\t\tObject param = HttpMessageConverterUtil.getObjectFromInputStream(\n\t    \t\t\t\trequest, clazzs[idx]);\n\t        \t//执行方法 \n\t        \tobject = pjp.proceed(new Object[]{args[0],args[1],param});\n\t    \t}else{\n\t    \t\tobject = pjp.proceed();\n\t    \t}\n\t    \n\t        return object;  \n\t    }     \n\t}\n\napplicationContext.xml:\n\t\n\t...\n\t<aop:aspectj-autoproxy/>\n\t\n\t<bean class=\"com.geyuxu.interceptor.ConverterInterceptor\" />\n\t...","tags":["RequestBody"]},{"title":"markdown学习笔记","url":"/2015/05/22/others/markdown学习笔记/","content":"\n1. markdown支持html\n------------------------------------------------------------\n\t\n\t<ol>      \n\t<li>Coffee</li>    \n\t<li>Milk</li>        \n\t</ol>\n\n<ol>\n<li>Coffee</li>\n<li>Milk</li>\n</ol>\n\n2. 标题\n------------------------------------------------------------\n\n#####写法一：\n\t\n\t# 一级标题\n\t## 二级标题\n\t### 三级标题\n\t...\n<!--more-->\n# 一级标题\n## 二级标题\n### 三级标题\n#### 四级标题\n##### 五级标题\n###### 六级标题\n\n#####写法二：\n\t\n\t一级标题\n\t===================\n\n\t二级标题\n\t--------------------\n\n\n3. 链接和图片\n------------------------------------------------------------\n\t写法一：[文字说明](链接地址)\n\n\t写法二：<http://github.geyuxu.com>\n[github.geyuxu.com](http://github.geyuxu.com)\n\n\t![文字说明](图片地址)\n\n4. 段落缩进和换行\n------------------------------------------------------------\n　　markdown在航首使用空格会被自动删除，而使用超过4个空格或者使用tab之后会被翻译成代码块。如果想使用缩进，可以在行首插入全角的空格实现。插一堆`&nbsp;`也可以实现，呵呵。。。  \n全半角转换：Shift + 空格\n\n　　常规换行是输入两个回车。markdown会删除多余的空格、换行（一个回车），在文本中输入的换行最终会被删除，浏览器根据可用空间自动换行。如果想强制换行，可以输入`</br >`或者在行尾输入两个以上的空格。\n\n5. 引用\n------------------------------------------------------------\n\n\t> 这是一个引用。这是第一行\n\t这是第二行。\n\t>> 这是一个嵌套的引用。这是第一行。\n\t这是第二行\n\t> \n\t> 外层引用的第三行。前面需要一个视觉上的空行表示内层嵌套的结束，空行前面的('>')可以有可以没有。\n> 这是一个引用。这是第一行\n这是第二行。\n>> 这是一个嵌套的引用。这是第一行。\n这是第二行\n> \n> 外层引用的第三行。前面需要一个视觉上的空行表示内层嵌套的结束，空行前面的('>')可以有可以没有。\n\n6. 水平线\n------------------------------------------------------------\n\t* * *\n\t*****\n\t- - -\n\t-----\n\n* * *\n\n参考：\n>[维基百科：Markdown](http://zh.wikipedia.org/wiki/Markdown)","tags":["markdown"]},{"title":"使用FileSystemWatcher监控文件和目录的变化","url":"/2015/05/22/dot-net/使用FileSystemWatcher监控文件和目录的变化/","content":"##常用属性：\n\nPath: 要监控的路径\n\nIncludeSubdirectories: 是否监控子目录\n\nFilter: 筛选器，如\n\t\n\t“*.jpg | *.doc”\n\nNotifyFilter: 设置哪些变动会触发事件\n\nEnableRaisingEvents: 设值是否开始监控\n\n##常用事件：\n\nChanged ： 更改文件和目录时\n\nCreated ： 创建文件和目录时\n\nDeleted ： 删除文件或目录时\n \nRenamed ： 重命名文件或目录时\n<!--more-->\n\tusing System;\n\tusing System.IO;\n\t\n\tnamespace ConsoleApplication1\n\t{\n\t    class Program\n\t    {\n\t        static void Main(string[] args)\n\t        {\n\t            FileSystemWatcher fsw = new FileSystemWatcher();\n\n\t            fsw.Path = \"C:\\\\test\";\n\n\t            fsw.IncludeSubdirectories = true;\n\n\t            fsw.Filter = \"*\";\n\n\t            fsw.NotifyFilter = NotifyFilters.FileName | NotifyFilters.DirectoryName | NotifyFilters.Size;\n\n\t            fsw.Created += new FileSystemEventHandler(fileSystemWatcher_EventHandle);\n\n\t            fsw.Deleted += new FileSystemEventHandler(fileSystemWatcher_EventHandle);\n\t\n\t            fsw.Changed += new FileSystemEventHandler(fileSystemWatcher_EventHandle);\n\t\n\t            fsw.Renamed += new RenamedEventHandler(fileSystemWatcher_Renamed);\n\t\n\t            fsw.EnableRaisingEvents = true;\n\t\n\t            Console.ReadKey();\n\t\n\t        }\n\t\n\t        private static void fileSystemWatcher_Renamed(object sender, RenamedEventArgs e)\n\t        {\n\t            showLog(e);\n\t        }\n\t\n\t        private static void fileSystemWatcher_EventHandle(object sender, FileSystemEventArgs e)\n\t        {\n\t            showLog(e);\n\t        }\n\t\n\t        private static void showLog(FileSystemEventArgs e)\n\t        { \n\t            Console.WriteLine(e.Name + \" \" + e.ChangeType + \" \" + e.FullPath); \n\t        }\n\t    }\n\t}\n![演示](http://img.geyuxu.com/2015-05-22-001.png)\n\n------------------------------------------------\n\n参考：\n\n>[FileSystemWatcher用法详解](http://blog.csdn.net/hwt0101/article/details/8469285)\n\n>[FileSystemWatcher 类（msdn）](https://msdn.microsoft.com/zh-cn/library/system.io.filesystemwatcher.aspx)\n\n>[Linux和Mac OS X 中监视文件变化](http://blog.163.com/vic_kk/blog/static/49470524201041301257208/)","tags":["FileSystemWatcher"]},{"title":"每天工作4小时的程序员","url":"/2015/05/21/reproduce/每天工作4小时的程序员/","content":"来源：[http://www.vaikan.com/daily-routine-of-a-4-hour-programmer/](http://www.vaikan.com/daily-routine-of-a-4-hour-programmer/)\n\n　　每个人都熟悉这种作息规律：早上9点去上班，坐在电脑前面，编一天的程序，下午5点下班回家。如今，非常感谢蒂莫西·费里斯 (Timothy Ferriss)的《每周工作4小时》，我开始重新思考应该如何工作，如何让自己变成更有效率的程序员。\n\n　　最近，我把我的从周一到周五的作息规律做了一次较大的调整。很长时间以来，我一直像所有其他程序员那样工作、休息。但就在2011年的下半年，我开始了一项试验，想看看究竟什么样的作息时间能让我更有效率。这项实验目前仍在进行中，我并不是像军人那样严格遵守实验规定——例如，我也想会早20分钟、或晚20分钟起床——但当前制定的作息规律是这样的：\n<!--more-->\n##早上4：30 到 7 点：冥想，写作，目标复查，和家人吃早餐\n\n　　早上4：30起床其实并不是你想象的那么难。每个人的个人情况都多少有些不同，但人的身体基本上需要每天7到9小时的睡眠时间。保证你睡眠充足的一个方法是不用闹钟自然醒。你只需要早点睡觉，你就可以在早上4：30醒来。\n\n　　起床之后，我会马上喝上16盎司的水——不是咖啡！我很长时间都不喝咖啡了，而且也不太想喝。事实上，不喝咖啡我感觉会更好。然后我会冲个澡；这样会让我感觉一个清爽的一天的开始。\n\n　　每天早上我都会冥想30分钟。冥想的最佳时间是在日出之前或日出的过程中，也就是西方世界的早6点之前。我不打算解释为什么冥想会对你有好处；网上对此已经有了大量的研究。如果你想找一个关于冥想的书，我推荐《Meditation for Dummies》。尽管书名很怪，但它是我读过的最好的一本书。\n\n　　冥想之后，我会花30-45分钟的时间写博客。我一般会写500到800字。我发现，冥想之后立即动笔，通常会一气呵成，写的很顺利。另外，大脑经过了一夜的休整，状态非常好，在注意力转移到其它事务之前，把大脑里堆积的东西都倒出来清理一下是很有好处的。关于写作的一个技巧：把这段时间用作对大脑的初步清理。不要去做研究、编辑等。这些事情放在以后再做。\n\n　　然后是To Do List(待办清单)时间。我会查看邮件，微博，LinkedIn，等等，以及安排下一步要做是任务。说到任务，我遵循GTD做事方法，我用Omnifocus软件来管理我的生活。我在iPad，iPhone和MacBook Air(我是苹果的粉丝)都装了它。不错，作为一个待办事宜管理软件，Omnifocus是有点贵了，但因为我的整个生活都和它有关，这个价格也值了。我通览一下待办清单，想想每个事情上的预期目标——所有的事情，从今天要做的小事情，到长期的目标。清单中的每个条目都设定有一个目标，如果没有目标，我会删除它。\n\n　　接着是早餐时间。关于应该什么时候吃早餐、应该吃什么的问题上，已经有大量你可以借鉴的养生指导。我尝试过各种不同的东西。我发现那些富含纤维素，低碳，高蛋白质的东西最适合我。你试过燕麦片加花生酱吗？好极了！我还喜欢吃一些水果、喝一点茶。还有，我尽量和家人一起吃早餐。有时事情能按照这种愿望执行，但有时不行。我的目标是今年一年都要按照这个执行下去。\n\n##早7点到11点：4个小时的编程时间\n\n　　这是我用来编程的时间。一天4小时也许你会觉得少的可怜，可是我却发现，在这4小时我做的事情能比大多数人一周干的事情都要多。研究显示，具有固定工作时间表的人比那些随机工作的人更有效率。对于我来说，这个固定时间是早7点到11点，每天。这段时间我要做的事情就是编程，不做其它的。有几个基本的原则：\n\n　　首先，关掉所有的通信设施——电话，邮件，聊天工具等。没有让你分心的事。你可以给少数几个人保留一个联系到你的方法，以防有紧急事情发生。那些真有紧急事情需要找你的人自有办法联系到你，我还没有碰到过这样的事。我甚至还教育我的妻子，她通常习惯对所有的请求都立即给予回应，我告诉她要尊重我这4个小时的时间。在这段时间里你应该只干一件事。千万不要同时干5、6件事情。\n\n　　第二，中间不要留下休息时间来查看邮件或上网，或干其它类似的事情。原因是：在一个小时里，我可以开发出x个功能。如果我要是连续工作4小时，我发现我的产量不是4倍，而是8倍或16倍。当你全神贯注的干某项事情时，相信你也经历过这样的体验。这就是我们所说的大脑的Flow(流)状态。在以后的博客里我打算多写一些关于Flow的文章。\n\n　　那为什么不把这样的制度应用到整个8小时的工作时间里呢？这是因为人的有效率的状态是有限度的。人的大脑跟肌肉一样。你可以在跑步机上持续运动8小时吗？就像我们的肌肉，大脑需要时不时的休息。这种限度依据个人的不同而各异。通过尝试和根据犯下的错误，我发现我的极限时间是4小时。\n\n　　还有一点需要提的是，我并没有在11点设了闹钟提示。当我感觉大脑有些疲倦，工作效率开始下降时，我就停止工作。有些天我只工作3小时，有时我会工作5小时；4小时是平均值。\n\n　　我在家工作是为了避开打搅。如果你需要在办公室里工作，看看管理部门是否允许你把最有效率的这段时间放在家里工作。你上班途中的折腾会把早上做瑜伽和冥想获得的好处给抵消了。在经过了早高峰的喧闹，还有办公室里的嘈杂，你的神经会变的紧张，冥思带来的效果完全消失。在家工作必定会更有效率的多。\n\n##早11点到下午1点：健身，午饭，购物\n\n　　我每天都要健身。John J. Ratey的书《Spark: The Revolutionary New Science of Exercise and the Brain 》对每天锻炼的好处做了很好的论证，如果你想知道锻炼对大脑功能改进的科学机理，你可以读一下这本书。每天不做相同的运动，甚至不去相同的健身房。我每周在一个瑜伽馆里做3次瑜伽，在一个spinning馆里上两天的spinning课，在健身房里做两天的举重，在健身房里我有个教练。教练帮助了我很多，有人这样督促你会使你具有更大的动力。\n\n　　我喜欢在健身房运动，因为那里有额外的服务。你可以一下用掉5条毛巾而不担心老婆的抱怨。可以花30分钟冲澡而不用担心门外有人叫喊”你还没完吗？“…在家里你经常会遇到这样的事。\n\n　　我还养成了一个习惯就是每天购物，通常是在Whole Foods，一个离我家只有步行距离的超市。为什么每天购物？在很多国家，特别是亚洲，人们每天都去购物，而不是一次买足2个星期的东西储存在家里的冰箱或冷柜里。这种方式，你只买了你需要的东西，避免了浪费。很多时候你会发现冰箱里有些不知是何物的东西，怀疑放在那里有半年之久了。我午饭在外面吃，Whole Foods超市里有不错的沙拉自助。因为我喜欢日本食品，有时我会来一点日本寿司或盒饭。\n\n##下午1点到6点：学习和交流时间\n\n　　我尽量会把一些讨论、约会时间凑到一起，这样不必每天都去公司。通常，这些事情包括会议，面试，做报告，指导开发，代码审查等等。这段时间我不做任何的开发，除非有紧急的bug或特殊情况需要处理。\n\n　　我还用很大比例的一部分时间去学习。我花了很多时间去阅读别人的东西，从书本到博格，大多与编程相关的东西。我每天都要学到新的知识。保持这样的学习劲头的最好的方法是对学到的东西做一些笔记，把相关的知识做写标记。像EverNote这样的软件很适合做这种事情。\n\n　　同时我会看看市场上有没有其它的产品，最有效率的软件开发者是不用写一行代码就能把问题解决。我不想把别人已经做好的东西再做一遍。所以，在CodePlex, GitHub 和 Component Source这些网站上花时间是有好处的。\n\n　　我从妻子的医院实习的经历中得到了一点启示。新入职的大夫每天早上看病，到了下午，他们会聚到一起讨论遇到的各种病症，讨论他们是如何应诊的。对于我，我会事后反省一下自己做过的事，我会重新思考一下早上编程遇到的问题，在什么地方遇到了什么bug，或反省做报告时的表现，或如何主持的会议，等等。我努力从过失中学到教训，避免它们再次出现。\n\n##下午6点到晚上8点：家庭时间\n\n　　我妻子是个医生，工作很忙，但我们尽量一起度过这段时间。我们会一起做饭。然后我会和孩子一起做家庭作业。(一个二年级的学生竟会有这样多的作业，这是另外一个话题，我以后再谈。)\n\n##晚8点到8：30：反省和给大脑派活\n\n　　我晚上不做冥思，而是换成坐下来反省一天的生活。如果你花上15分钟做在一个安静的地方反省你的一天，你会吃惊的发现这一天你学到了这样多的东西，获得了这样大的提高。\n\n　　接下来，我给大脑安排工作。众所周知，当我们睡眠时大脑是在不停工作的。所以，你最好给它安排点工作。对于我，下面这些事情很有效：我把第二天早上要写的东西做了个大纲。就像写便条一样。我发现把它写到纸上比写在电脑里更有效。\n\n　　或者，我会看一些编程/算法问题。同样，会纸上描述下来或写出框架。让人惊奇的是，很多时候早上起来你会发现已经有了解决方案！像这样的事情我是在一个整洁的、没有格线的、信封大小的笔记本上写画的。在空白的白纸上写画会让我更有灵感。我在晚8：30到9点间上床睡觉。越早越好。\n\n　　这就是我一天的作息时间。当然，当我外出旅行时会有些变化；在途中我会花大量的时间来工作。我还没有告诉你们在周末我都干些什么，我会在以后的文章里讲到这些。\n\n　　我很想听到其他人关于他们的作息时间的故事，以及他们是如何提高工作效率的。\n\n\n参考：\n\n>[英文原文](http://www.vaikan.com/daily-routine-of-a-4-hour-programmer/)","tags":["转载"]},{"title":"和我一起学习clojureClr-调用.Net","url":"/2015/05/21/clojure/002-和我一起学习clojureClr-调用.Net/","content":"打开REPL，输入：\n\n\t(System.Console/WriteLine \"********\")\n![演示](http://img.geyuxu.com/2015-5-20-011.png)\n\n显然，可以通过这种形式调用.Net方法。但不够美观，我们将代码做一个封装。\n\t\n\t(defn writeline [message]\n\t\t(System.Console/WriteLine message))\n![演示](http://img.geyuxu.com/2015-5-20-012.png)\n<!--more-->\n既然可以用Console，能不能使用MessageBox呢？当然可以，以下代码加载MessageBox。\n\n\t(System.Reflection.Assembly/Load \"System.Windows.Forms, Version=2.0.0.0, \n\t Culture=neutral, PublicKeyToken=b77a5c561934e089\")\n\n\t(import (System.Windows.Forms MessageBox))\n![演示](http://img.geyuxu.com/2015-5-20-013.png)\n\t\n\t(MessageBox/Show \"内容\" \"标题\")\n![演示](http://img.geyuxu.com/2015-5-20-014.png)\n\n封装MessageBox\n\n\t(defn show-message \n\t\t([content] (show-message content \"Message\")) \n\t\t([content title] (MessageBox/Show content title)))\n![演示](http://img.geyuxu.com/2015-5-20-015.png)\n\n显示消息框是一件很无聊的事情，WinForms 怎么能没有form，说干就干。\n\n\t(import (System.Windows.Forms Form))\n\t(.Show (Form.))\n![演示](http://img.geyuxu.com/2015-5-20-016.png)\n\nform是出来了，但是form上面什么都没有，并且程序死掉了。先这样吧，睡觉了。\n\n参考：\n\n>[clojure 新手指南（10）:与java交互](http://my.oschina.net/clopopo/blog/143000)\n\n>[Clojure CLR 入门](http://www.cnblogs.com/me-sa/archive/2013/03/25/2981192.html)\n\n>[Clojure - Functional Programming for the JVM](http://java.ociweb.com/mark/clojure/article.html)\n","tags":["clojure-clr"]},{"title":"和我一起学习clojureClr-Hello World","url":"/2015/05/20/clojure/001-和我一起学习clojureClr/","content":">俗话说的好，java能做的事.net也能做，java不能做的事，.net还是能做。。。\n<!--more-->\n在官网下载最新版本的clojureClr\n\n[主页](https://github.com/clojure/clojure-clr) \n\n[下载页面](https://github.com/clojure/clojure-clr/wiki/Getting-binaries)\n\n我是在SourceForge下载 [https://sourceforge.net/projects/clojureclr/files/](https://sourceforge.net/projects/clojureclr/files/)\n\n将压缩包解压到你方便操作的目录\n![演示](http://img.geyuxu.com/2015-5-20-001.png)\n\n###使用REPL\n\n运行Clojure.Main.exe，进入REPL界面。\n![演示](http://img.geyuxu.com/2015-5-20-002.png)\n\n万年不变的hello world\n\n\t(println \"hello world\")\n![演示](http://img.geyuxu.com/2015-5-20-003.png)\n\n###栗子\n\n创建目录结构和文件com\\geyuxu\\examples\\hello.clj\n\n![演示](http://img.geyuxu.com/2015-5-20-004.png)\n\n在hello.clj中输入以下代码\n\n\t(defn hello [name]\n\t\t(str \"hello, \" name))\n\n保存hello.clj后，回到REPL中输入\n\n\t(use 'com.geyuxu.examples.hello)\n\n\t(hello \"geyuxu\")\n![演示](http://img.geyuxu.com/2015-5-20-006.png)\n\n![演示](http://img.geyuxu.com/2015-5-20-007.png)\n\n我们来简单分析一下：\n\n1. use '  类似于java的import xxx或者c#的using xxx，但有所不同，这个以后再说。注意，上引号不可以丢掉。\n\n2. 创建一个函数的方法\n\t\t\n\t\t(defn 函数名 [参数] (函数体))\n\n3. 调用函数\n\t\n\t\t(函数名 参数)\n\n\n######参考：\n\n> [Clojure CLR 入门](http://www.cnblogs.com/me-sa/archive/2013/03/25/2981192.html)\n \n> [《Clojure程序设计》](http://book.douban.com/subject/21459993/)\n\n> [《Clojure编程》](http://book.douban.com/subject/21661495/)\n\n> [clojure官网](http://clojure.org/)","tags":["clojure-clr"]},{"title":"服务端工程师入门与进阶Java版","url":"/2015/05/19/reproduce/服务端工程师入门与进阶Java版/","content":"来源：[http://www.kuqin.com/shuoit/20150420/345784.html](http://www.kuqin.com/shuoit/20150420/345784.html)\n\n前言\n====\n\n　　欢迎加入我们。这是一份针对实习生/毕业生的服务端开发入门与进阶指南。遇到问题及时问你的 \nmentor 或者直接问我。 建议：\n\n* 尽量用google查找技术资料。\n\n* 有问题在stackoverflow找找，大部分都已经有人回答。\n\n* 多看官方的技术文档。\n\n* ibm developerworkers的文章质量整体上有保障。\n\n* 平时花一些时间在github上阅读优秀项目源码。\n<!--more-->\n入门（1-2 个月）\n==============\n\n1. 目标：参与简单的项目开发。\n\n2. 技能：\n\t\n\t* 掌握 Java。经典的《Java 核心技术：卷1 基础知识》(或者《Java 编程思想》)必看，跳过其中的图形和 applet 章节。习惯通过 Java API Doc。为了保证代码的质量，《Effective Java》、《Clean Code》和《重构》也需要至少通读一遍。\n\t\n\t* 熟悉 Linux 开发环境和 bash shell。Linux 是我们的开发和部署环境，你最好尽快熟练它。Linux 的基本使用可以通过《鸟哥的Linux私房菜：基础学习篇（第三版）》学习，开发 bash shell 脚本可以参考《Linux Shell脚本攻略》。\n\t\n\t* 掌握开发工具\n\t\t* 熟练使用一种 IDE。Intellij IDEA或者 Eclipse 都可以，推荐使用前者。至少熟悉常用的快捷键，会 debug(包括远程 debug)项目。\n\t\t* 熟悉一种编辑器。比如 Vim/Emacs，至少学会搜索/替换/代码补全。\n\n3. 掌握 JDK 以外的常用类库和工具包。JDK 原生 API 在很多场景下使用并不方便。你需要掌握社区贡献的优秀类库和工具包，比如 apache commons、google guava 等，具体可以翻阅《技术选型手册》的Utility 篇。\n\n4. 掌握 Web 开发框架。我们使用 Spring(或Rose) + Ibatis(或Jade) 开发 web 服务，你需要熟练掌握它们。\n\n5. 学习代码规范。我们大致上遵循 oracle 的 Java 语言编码规范，你可以先阅读并熟悉它。Code Formatting 文件在 git@git.n.xiaomi.com:xiaomi-commons/coding-standard.git，在编写代码之前，请把它导入到 IDE 中。另外，确认 IDE 已经安装 Findbugs 和 CheckStyle 插件。\n\n6. 熟悉开发流程。我们的开发流程大致如下：功能开发->单元测试->功能测试->Code Review->集成测试->发布。确保你熟悉其中的每个环节。\n\n7. 其他。需要熟练使用版本控制工具 Git（阅读：《Git 权威指南》），以及项目构建工具 Maven（阅读：《Maven实战》）。另外，在这个阶段可以尝试 TDD 开发。\n\n进阶（2-6 个月）\n==============\n\n* 目标：独立负责某个服务端项目。\n\n* 技能：\n\t\n\t* 掌握 web 开发最佳实践，掌握 Restful API 设计，理解 Spring 原理。推荐阅读《Spring 揭秘》。掌握项目分层、子模块划分。推荐阅读：《J2EE 核心模式》。\n\t\n\t* 掌握 web 架构设计。包括 Http 反向代理，数据缓存，负载均衡，水平扩展和垂直扩展。推荐阅读：《分布式Java应用：基础与实践》。\n\t\n\t* 掌握关系型数据库。包括设计 MySQL 表结构，根据业务特点分表分库，基于执行计划的 SQL 分析优化，以及数据库容量规划。推荐阅读：《MySQL 必知必会》、《高性能 MySQL》。\n\t\n\t* 了解 NoSQL。我们大规模使用 Hadoop、HBase、Hive，同时部分项目使用 Redis、Storm。你需要学会这些工具最基本的使用。\n\t\n\t* 学习 web 安全知识。了解 web 前端安全问题。设计安全 web 服务，包括加解密、防伪造、防重放攻击等。\n\t\n\t* 掌握 Http(推荐阅读：《图解 Http》、《Http 权威指南》)、Thrift 等协议。\n\t\n\t* 掌握服务容量规划，性能调优，可靠性保证，以及故障处理。学习容量规划和性能调优知识，梳理业务监控点，熟练使用我们的监控报警系统。推荐阅读：《深入理解 Java 虚拟机》。\n\t\n\t* 其他。设计模式：从项目中学习，有时间可以看看《深入浅出设计模式》、《JDK 里的设计模式》。学习Java Socket 编程与多线程知识，可以看看《Java 并发编程实战》，并翻翻并发编程网的文章。\n\n深入（6 个月-）\n=============\n\t\n* 目标：分布式系统和中间件开发。\n\n* 构建知识体系：《大型网站系统与 Java 中间件实践》、《大型网站技术架构：核心原理与案例分析》。\n\n* 原理与设计：《大规模存储式系统》、《UNIX 网络编程 卷1:套接字联网 API》、《How Tomcat Works》。\n\n* 学习开源项目：Apache Thrift、Zipkin、Netty、Rose、Jade、淘宝 RPC 系统 Dubbo 等。分析项目中的设计思路。比如，同样是RPC框架，Finagle 和 Dubbo 有什么异同。\n\n* 其他。根据参与的项目加深学习吧。比如，如果需要写 DSL，可以读一下《领域特定语言》，对 Redis 感兴趣推荐读一下：《Redis 设计与实现》。有两本书，无论做什么项目，都推荐读：《Unix 编程艺术》、《UNIX 环境高级编程(第3版)》。","tags":["转载"]},{"title":"使用hexo","url":"/2015/05/18/others/使用hexo/","content":"\n\n\n准备工作\n-------------------------------------------------------------------------\n安装nodejs\n\n\n安装hexo\n-------------------------------------------------------------------------\n\n1.安装hexo-cli\n\t\n\tnpm install hexo-cli -g\n\n2.初始化blog文件夹\n\t\n\thexo init blog\n\n如果当前文件夹是空文件夹，也可以省略“blog”。\n\n![演示](http://img.geyuxu.com/2015-5-19-003.png)\n<!--more-->\n3.用npm安装依赖包\n\t\n\tcd blog\n\tnpm install\n![演示](http://img.geyuxu.com/2015-5-19-004.png)\n\n4.启动hexo服务器，预览效果\n\t\n\thexo server\n![演示](http://img.geyuxu.com/2015-5-19-005.png)\n\n用浏览器打开[http://localhost:4000](http://localhost:4000)\n\n![演示](http://img.geyuxu.com/2015-5-19-006.png)\n\n恭喜你，拥有了自己的网站:)\n\n\n用hexo写一篇日志\n-------------------------------------------------------------------------\n\n输入命令在source\\_posts目录下新建一个markdown文件\n\n\thexo new 服务端工程师入门与进阶Java版\n![演示](http://img.geyuxu.com/2015-5-19-007.png)\n\n用markdown编辑器打开文件，并编辑。\n![演示](http://img.geyuxu.com/2015-5-19-008.png)\n\n输入\n\n\thexo g\n\thexo s\n\n在网页中查看效果\n\n![演示](http://img.geyuxu.com/2015-5-19-009.png)\n\n\n--------------------------------------------------------------------------\n>[nodejs官网](https://nodejs.org/)\n>\n>[hexo官网](http://hexo.io/)\n>\n>[yilia主题](https://github.com/litten/hexo-theme-yilia)\n>\n>[《服务端工程师入门与进阶Java版》原文](http://www.kuqin.com/shuoit/20150420/345784.html)\n>\n>[文中使用的markdown编辑器](http://markdownpad.com/)","tags":["hexo"]}]